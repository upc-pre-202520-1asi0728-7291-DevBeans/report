<div align="center">
    <h3>Universidad Peruana de Ciencias Aplicadas</h3>
    <img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png"></img><br>
    <strong>Ingeniería de Software</strong><br><br>
    <strong>Arquitectura de Software Emergentes</strong><br>
    1ASI0728
    <br><strong>NRC 7291</strong><br>
    <br><strong>Profesor: Royer Edelwer Rojas Malasquez</strong><br>
    <br><strong>Report</strong><br>
    <br><strong>DevBeans Startup</strong><br>
    <!--<strong>name startup</strong>-->
    <br><h3> Integrantes: </h3>
</div>

<div align="center">

| Member                              |    Code    |
| :---------------------------------- | :--------: |
| Aranda Vallejos, Oscar Gabriel      | U202218167 |
| Apellidos, Nombres                  | U20...     |
| Apellidos, Nombres                  | U20...     |
| Apellidos, Nombres                  | U20...     |

</div>

<h3 align="center">Mayo, 2025</h3>

<br><br>

<div align="justify">



## Registro de Versiones del Informe

En esta sección se resumen los avances y modificaciones realizadas durante el ciclo de vida de desarrollo del proyecto equivalente a un semestre.

<table>
  <thead>
    <tr>
      <th>Versión</th>
      <th>Fecha</th>
      <th>Autor</th>
      <th>Descripción de modificación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.0</td>
      <td>09/09/2025</td>
      <td>...</td>
      <td>Creación y estructuración del informe</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1.X</td>
      <td>Fecha</td>
      <td>Apellido, Nombre</td>
      <td>...</td>
    </tr>
  </tbody>
</table>
<br>


# Project Report Collaboration Insights

<br>Se utilizaron Git y Github como herramientas fundamentales para el versionamiento y gestión del proyecto, lo cual permite una mejor colaboración y visualización de cambios en tiempo real. A continuación, se proporcionan los siguientes enlaces del proyecto:

| **Descripción**            | **Enlace**                                                                 |
| :-------------------------: | :------------------------------------------------------------------------: |
| Repositorio de la documentación    | https://github.com/upc-pre-202520-1asi0728-7291-DevBeans/report         |
| Organización del proyecto     | https://github.com/upc-pre-202520-1asi0728-7291-DevBeans                    |

<!--LO COMPLETARE DESPUES -->

<br>

# Contenido

## Tabla de Contenidos

### [Registro de Versiones del Informe](#registro-de-versiones-del-informe)

### [Project Report Collaboration Insights](#project-report-collaboration-insights)

### [Contenido](#contenido)

### [Student Outcomes](#student-outcome)

### [Capítulo I: Introducción](#capítulo-i-introducción)
  - [1.1. Startup Profile](#11-startup-profile)
    - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
    - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
  - [1.2. Solution Profile](#12-solution-profile)
    - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problemática)
    - [1.2.2. Lean UX Process](#122-lean-ux-process)
      - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
      - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
          - [**Business Outcomes:**](#business-outcomes)
          - [**Users:**](#users)
          - [**User Outcomes \& Benefits:**](#user-outcomes--benefits)
          - [**Feature Assumptions:**](#feature-assumptions)
          - [**Business Assumptions:**](#business-assumptions)
          - [**User Assumptions:**](#user-assumptions)
      - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)
      - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
  - [1.3. Segmentos objetivo](#13-segmentos-objetivo)

### [Capítulo II: Requirements Elicitation & Analysis](#capítulo-ii-requirements-elicitation--analysis)
- [2.1. Competidores](#21-competidores)
  - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
  - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
- [2.2. Entrevistas](#22-entrevistas)
  - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
  - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
  - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
- [2.3. Needfinding](#23-needfinding)
  - [2.3.1. User Personas](#231-user-personas)
  - [2.3.2. User Task Matrix](#232-user-task-matrix)
  - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
  - [2.3.4. Empathy Mapping](#234-empathy-mapping)
  - [2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping)
- [2.4. Ubiquitous Language](#24-ubiquitous-language)

### [Capítulo III: Requirements Specification](#capítulo-iii-requirements-specification)
- [3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)
- [3.2. User Stories](#32-user-stories)
- [3.3. Impact Mapping](#33-impact-mapping)
- [3.4. Product Backlog](#34-product-backlog)

### [Capítulo IV: Solution Software Design](#capítulo-iv-solution-software-design)
- [4.1. Strategic-Level Domain-Driven Design](#41-strategic-level-domain-driven-design)
  - [4.1.1. Event Storming](#411-event-storming)
    - [4.1.1.1 Candidate Context Discovery](#4111-candidate-context-discovery)
    - [4.1.1.2 Domain Message Flows Modeling](#4112-domain-message-flows-modeling)
    - [4.1.1.3 Bounded Context Canvases](#4113-bounded-context-canvases)
  - [4.1.2. Context Mapping](#412-context-mapping)
  - [4.1.3. Software Architecture](#413-software-architecture)
    - [4.1.3.1. Software Architecture System Landscape Diagram](#4131-software-architecture-system-landscape-diagram)
    - [4.1.3.2. Software Architecture Context Level Diagrams](#4132-software-architecture-context-level-diagrams)
    - [4.1.3.3. Software Architecture Deployment Diagrams](#4133-software-architecture-deployment-diagrams)
- [4.2. Tactical-Level Domain-Driven Design](#42-tactical-level-domain-driven-design)
  - [4.2.1. Bounded Context: IAM](#421-bounded-context-iam)
    - [4.2.1.1. Domain Layer](#4211-domain-layer)
    - [4.2.1.2. Interface Layer](#4212-interface-layer)
    - [4.2.1.3. Application Layer](#4213-application-layer)
    - [4.2.1.4. Infrastructure Layer](#4214-infrastructure-layer)
    - [4.2.1.6. Bounded Context Software Architecture Component Level Diagrams](#4216-bounded-context-software-architecture-component-level-diagrams)
    - [4.2.1.7. Bounded Context Software Architecture Code Level Diagrams](#4217-bounded-context-software-architecture-code-level-diagrams)
      - [4.2.1.7.1. Bounded Context Domain Layer Class Diagrams](#42171-bounded-context-domain-layer-class-diagrams)
      - [4.2.1.7.2. Bounded Context Database Design Diagram](#42172-bounded-context-database-design-diagram)

### [Conclusiones](#conclusiones)
### [Bibliografía](#bibliografía)
### [Anexos](#anexos)

---

# Student Outcome

<!-- Yo me encargo de completar sus student outcomes muchachos -->


# Capítulo I: Introducción

## 1.1. Startup Profile

### 1.1.1. Descripción de la Startup

...

Misión:
...

Visión:
...


### 1.1.2. Perfiles de integrantes del equipo

|           Photo                        |                                                                                                                                                                                                                                                                                                    Description                                                                                                                                                                                                                                                                                                    |
| :------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| <img src="https://i.postimg.cc/6qRCcvNF/Captura-de-pantalla-2024-09-08-151747.png"> | **Aranda Vallejos, Oscar Gabriel** <br> Tengo 20 años y soy estudiante de la carrera de Ingeniería de Software, poseo conocimientos básicos en Unity, C++ y diseño web. Me considero una persona preparada y perseverante en cumplir con los objetivos del proyecto; además, siempre estoy dispuesto a aprender nuevos conceptos.            |
| photo | **Apellido, Nombre** <br> Estoy cursando la carrera de Ingeniería de Software, me gusta jugar videojuegos y aprender cosas nuevas en mis ratos libres. Aspiro a trabajar como desarrollador fullstack y me interesa mantenerme actualizado en nuevas tecnologías, buenas prácticas de programación y metodologías ágiles. |
| photo | **Apellido, Nombres** <br> Tengo 21 años, actualmente me encuentro cruzando mi 7mo ciclo de la carrera de ingeniería de software en la UPC. Me gusta jugar videojuegos y practicar natación, soy un gran aficionado de la tecnología y del ensamblaje de computadoras. Me considero una persona dispuesta siempre a aprender tecnologías nuevas, creativa y responsable.         |
| photo | **Apellido, Nombres** <br> Me gusta mucho aprender cosas nuevas sobre mi carrera, trabajar en equipo de manera proactiva y lograr los objetivos junto a mis compañeros. Me considero una persona ambiciosa, ya que mi meta es llegar a obtener un alto cargo en una empresa que me agrade o formar mi propia empresa relacionada al software. Gracias a ello siempre podré trabajar en algo que me guste y llevar una vida cómoda. Cuento con conocimientos de C + + y HTML. |


## 1.2. Solution Profile

### 1.2.1. Antecedentes y problemática

<!-- Contenido de antecedentes y problemática -->

### 1.2.2. Lean UX Process

#### 1.2.2.1. Lean UX Problem Statements

<!-- Contenido de Lean UX Problem Statements -->

#### 1.2.2.2. Lean UX Assumptions

##### **Business Outcomes:**

<!-- Contenido de Business Outcomes -->

##### **Users:**

<!-- Contenido de Users -->

##### **User Outcomes & Benefits:**

<!-- Contenido de User Outcomes & Benefits -->

##### **Feature Assumptions:**

<!-- Contenido de Feature Assumptions -->

##### **Business Assumptions:**

<!-- Contenido de Business Assumptions -->

##### **User Assumptions:**

<!-- Contenido de User Assumptions -->

#### 1.2.2.3. Lean UX Hypothesis Statements

<!-- Contenido de Lean UX Hypothesis Statements -->

#### 1.2.2.4. Lean UX Canvas

<!-- Contenido de Lean UX Canvas -->

## 1.3. Segmentos objetivo

<!-- Contenido de Segmentos objetivo -->

---

# Capítulo II: Requirements Elicitation & Analysis

## 2.1. Competidores

### 2.1.1. Análisis competitivo

<!-- Contenido del análisis competitivo -->

### 2.1.2. Estrategias y tácticas frente a competidores

<!-- Contenido de estrategias y tácticas frente a competidores -->

## 2.2. Entrevistas

### 2.2.1. Diseño de entrevistas

<!-- Contenido del diseño de entrevistas -->

### 2.2.2. Registro de entrevistas

<!-- Contenido del registro de entrevistas -->

### 2.2.3. Análisis de entrevistas

<!-- Contenido del análisis de entrevistas -->

## 2.3. Needfinding

### 2.3.1. User Personas

<!-- Contenido de User Personas -->

### 2.3.2. User Task Matrix

<!-- Contenido de User Task Matrix -->

### 2.3.3. User Journey Mapping

<!-- Contenido de User Journey Mapping -->

### 2.3.4. Empathy Mapping

<!-- Contenido de Empathy Mapping -->

### 2.3.5. As-is Scenario Mapping

<!-- Contenido de As-is Scenario Mapping -->

## 2.4. Ubiquitous Language

<!-- Contenido de Ubiquitous Language -->

---

# Capítulo III: Requirements Specification

## 3.1. To-Be Scenario Mapping

<!-- Contenido de To-Be Scenario Mapping -->

## 3.2. User Stories

<!-- Contenido de User Stories -->

## 3.3. Impact Mapping

<!-- Contenido de Impact Mapping -->

## 3.4. Product Backlog

<!-- Contenido de Product Backlog -->

---

# Capítulo IV: Solution Software Design

## 4.1. Strategic-Level Domain-Driven Design

### 4.1.1. Event Storming

Con el objetivo de que todos los integrantes puedan mantener la misma comprensión del dominio de nuestro producto de software, se llevó a cabo una sesión de Event Storming de aproximadamente 1 hora. Esto permitió que nosotros como equipo organizaramos nuestras ideas y pensamientos para identificar los eventos clave, comandos, usuarios y agregados del sistema, lo cuales son importantes para ofrecer una primera visión integral de este.

[![Captura-de-pantalla-2025-09-17-164413.png](https://i.postimg.cc/h4VRmT50/Captura-de-pantalla-2025-09-17-164413.png)](https://postimg.cc/grc7FXdw)

#### 4.1.1.1 Candidate Context Discovery

En esta sección se visualizan nuestros bounded context candidatos, los cuales se formaron a partir del event storming:

[![Captura-de-pantalla-2025-09-20-130515.png](https://i.postimg.cc/5tWgQFpk/Captura-de-pantalla-2025-09-20-130515.png)](https://postimg.cc/5XpLZyhw)

https://lucid.app/lucidchart/5207a245-2b65-413c-b65f-055daf5730ba/edit?viewport_loc=2510%2C-447%2C3981%2C1776%2CVluR_3p1AnhQ&invitationId=inv_96e8a5f1-1725-48e3-b572-4ff22f7fe447

**Bounded Context: IAM & Profile**

[![Captura-de-pantalla-2025-09-20-150500.png](https://i.postimg.cc/MKLNLbJF/Captura-de-pantalla-2025-09-20-150500.png)](https://postimg.cc/0bpVMSQY)

**Bounded Context: Coffee Lot Management**

[![Captura-de-pantalla-2025-09-20-150527.png](https://i.postimg.cc/B6NwB2CN/Captura-de-pantalla-2025-09-20-150527.png)](https://postimg.cc/ZBBcTB2y)

**Bounded Context: Grain Classification**

[![Captura-de-pantalla-2025-09-20-150557.png](https://i.postimg.cc/nVRPsYrh/Captura-de-pantalla-2025-09-20-150557.png)](https://postimg.cc/grhDQh3C)

**Bounded Context: Traceability & Certification**

[![Captura-de-pantalla-2025-09-20-150623.png](https://i.postimg.cc/K8Lqs6N1/Captura-de-pantalla-2025-09-20-150623.png)](https://postimg.cc/yD1yDr2K)

**Bounded Context: Reporting & Analytics**

[![Captura-de-pantalla-2025-09-20-150704.png](https://i.postimg.cc/Sx0V8Zhk/Captura-de-pantalla-2025-09-20-150704.png)](https://postimg.cc/ykPFCyxb)

**Bounded Context:User Support**

[![Captura-de-pantalla-2025-09-20-150745.png](https://i.postimg.cc/6QchktGp/Captura-de-pantalla-2025-09-20-150745.png)](https://postimg.cc/rddWW6JB)


#### 4.1.1.2 Domain Message Flows Modeling

Para dar inicio con el diseño de nuestro software, es de suma importancia el uso de los Domain Message Flows Modeling, ya que nos permite ilustrar la transferencia de información entre los diferentes componentes que interactúan en nuestro sistema conjunto. Además, el uso de esta metodología permite detectar problemas potenciales en la lógica del negocio de manera más rápida y sencilla.

<!-- Contenido de Domain Message Flows Modeling -->
[![Captura-de-pantalla-2025-09-20-140350.png](https://i.postimg.cc/NFzHwW5r/Captura-de-pantalla-2025-09-20-140350.png)](https://postimg.cc/p5KTfcQ2)

[![Captura-de-pantalla-2025-09-20-140426.png](https://i.postimg.cc/NGz9LvjK/Captura-de-pantalla-2025-09-20-140426.png)](https://postimg.cc/G9vhSNYR)

#### 4.1.1.3 Bounded Context Canvases

Los Bounded Context Canvas ayudan a definir claramente los límites de un bounded context y a capturar en un solo lugar la información clave del contexto, como el propósito, los usuarios principales, el lenguaje ubicuo, las entidades, reglas de negocio y relaciones con otros contextos.

<!-- Contenido de Bounded Context Canvases -->

**Bounded Context: IAM & Profile**

[![bc-canvas-1.jpg](https://i.postimg.cc/4N8sx9k6/bc-canvas-1.jpg)](https://postimg.cc/6yGDHTQq)

**Bounded Context: Coffee Lot Management**

[![bc-canvas-2.jpg](https://i.postimg.cc/QdwDpZMV/bc-canvas-2.jpg)](https://postimg.cc/fVc1NFmh)

**Bounded Context: Grain Classification**

[![bc-canvas-3.jpg](https://i.postimg.cc/BnLbWgLL/bc-canvas-3.jpg)](https://postimg.cc/CR0Skb4S)

**Bounded Context: Traceability & Certification**

[![bc-canvas-4.jpg](https://i.postimg.cc/tChyFMxz/bc-canvas-4.jpg)](https://postimg.cc/SJNwhVVX)

**Bounded Context: Reporting & Analytics**

[![bc-canvas-5.jpg](https://i.postimg.cc/RVMgvvtf/bc-canvas-5.jpg)](https://postimg.cc/vDNrzF3H)

**Bounded Context:User Support**

[![bc-canvas-6.jpg](https://i.postimg.cc/RZ21JmWg/bc-canvas-6.jpg)](https://postimg.cc/mPN1K0N9)





### 4.1.2. Context Mapping

<!-- Contenido de Context Mapping -->

### 4.1.3. Software Architecture

#### 4.1.3.1. Software Architecture System Landscape Diagram

En el diseño de la arquitectura del sistema se empleó el modelo C4, específicamente los diagramas de Context y Container, con el fin de representar de manera jerárquica y clara los diferentes niveles de abstracción. El Context Diagram permitió identificar a los actores externos y su interacción con el sistema, mientras que el Container Diagram detalló los principales componentes lógicos, servicios y aplicaciones que conforman la solución, así como sus relaciones. Adicionalmente, se incluyó un Deployment Diagram, que describe cómo los distintos elementos se distribuyen en la nube. 

Para el desarrollo de los diagramas C4 se utilizó la plataforma de Structurizr y se siguieron los siguientes lineamientos para las figuras:

[![structurizr-106404-Dev-Beans-Diagram-Contenedores-key.png](https://i.postimg.cc/Kcs2Mp51/structurizr-106404-Dev-Beans-Diagram-Contenedores-key.png)](https://postimg.cc/kD8zrczC)

#### 4.1.3.2. Software Architecture Context Level Diagrams

El Context Diagram muestra el sistema como una “caja negra” y lo ubica dentro de su ecosistema. En este nivel se identifican los usuarios, sistemas externos y actores clave, junto con las interacciones que tienen con la solución propuesta.

[![structurizr-106404-Diagrama-Contexto.png](https://i.postimg.cc/cJq18k0R/structurizr-106404-Diagrama-Contexto.png)](https://postimg.cc/5X3Wh3Hy)

#### 4.1.3.3. Software Architecture Container Level Diagrams

El Container Diagram descompone el sistema en sus principales contenedores de software (aplicaciones, bases de datos, APIs, bounded contexts, etc) y define cómo se comunican entre sí.

[![structurizr-106404-Dev-Beans-Diagram-Contenedores.png](https://i.postimg.cc/c1fzsDbq/structurizr-106404-Dev-Beans-Diagram-Contenedores.png)](https://postimg.cc/CdL7740J)

#### 4.1.3.4. Software Architecture Deployment Diagrams

[![Captura-de-pantalla-2025-09-20-172320.png](https://i.postimg.cc/TYwP8WtD/Captura-de-pantalla-2025-09-20-172320.png)](https://postimg.cc/xqwQMqDf)


# 4.2. Tactical-Level Domain-Driven Design

## 4.2.1. Bounded Context: IAM & Profile

El **IAM & Profile Bounded Context** es responsable de gestionar la autenticación, autorización y perfiles de usuarios en el sistema BeanDetect AI. Este contexto asegura que los usuarios (Productores Independientes y Cooperativas) puedan registrarse, iniciar sesión y gestionar sus perfiles de manera segura, cumpliendo con los estándares de seguridad y privacidad.

### 4.2.1.1. Domain Layer

La Domain Layer del IAM & Profile Bounded Context encapsula la lógica de negocio relacionada con la gestión de usuarios y perfiles. En esta capa se definen los elementos principales del dominio: agregados, entidades y objetos de valor que representan los conceptos clave del sistema.

#### **Aggregates**
1. **User**
   - **Propósito**: El agregado principal que encapsula la lógica de negocio relacionada con la autenticación y gestión de usuarios.
   - **Atributos**:
     - `email`: Correo electrónico único del usuario, validado para cumplir con formato estándar.
     - `password`: Contraseña del usuario, almacenada de forma segura con hashing.
     - `userType`: Tipo de usuario (Productor o Cooperativa), representado como enum `UserType`.
     - `status`: Estado del usuario (activo, inactivo, suspendido).
     - `profile`: Perfil específico según el tipo de usuario.
   - **Métodos**:
     - `changePassword(String newPassword)`: Cambia la contraseña del usuario.
     - `updateProfile(Profile profile)`: Actualiza el perfil del usuario.
     - `activate()`: Activa la cuenta del usuario.
     - `suspend()`: Suspende temporalmente la cuenta.
   - **Características**:
     - Extiende `AuditableAbstractAggregateRoot` para auditar cambios.
     - Gestiona la relación con el perfil específico según el tipo de usuario.

2. **Profile**
   - **Propósito**: Agregado que representa el perfil específico de cada usuario.
   - **Atributos**:
     - `personalInfo`: Información personal básica, representada como objeto de valor `PersonalInformation`.
     - `contactInfo`: Información de contacto, representada como objeto de valor `ContactInformation`.
     - `farmInfo`: Información específica de la finca (para productores) o cooperativa.
   - **Métodos**:
     - `updatePersonalInfo(PersonalInformation info)`: Actualiza información personal.
     - `updateContactInfo(ContactInformation info)`: Actualiza información de contacto.
     - `updateFarmInfo(FarmInformation info)`: Actualiza información de la finca.

#### **Entities**
1. **ProducerProfile**
   - **Propósito**: Entidad que representa el perfil específico de un productor independiente.
   - **Atributos**:
     - `farmName`: Nombre de la finca.
     - `location`: Ubicación geográfica de la finca.
     - `hectares`: Extensión en hectáreas.
     - `coffeeVarieties`: Variedades de café cultivadas.
     - `productionCapacity`: Capacidad de producción anual.
   - **Métodos**:
     - `addCoffeeVariety(String variety)`: Agrega una variedad de café.
     - `updateLocation(Location location)`: Actualiza la ubicación.

2. **CooperativeProfile**
   - **Propósito**: Entidad que representa el perfil de una cooperativa cafetalera.
   - **Atributos**:
     - `cooperativeName`: Nombre oficial de la cooperativa.
     - `associatedProducers`: Lista de productores asociados.
     - `processingCapacity`: Capacidad de procesamiento de la cooperativa.
     - `certifications`: Certificaciones obtenidas.
   - **Métodos**:
     - `addAssociatedProducer(ProducerId producerId)`: Asocia un productor.
     - `updateProcessingCapacity(Integer capacity)`: Actualiza capacidad.

#### **Value Objects**
1. **PersonalInformation**
   - Representa información personal básica.
   - **Atributos**: `firstName`, `lastName`, `documentNumber`, `documentType`.
   - **Validaciones**: Nombres no nulos, documento válido según tipo.

2. **ContactInformation**
   - Representa información de contacto.
   - **Atributos**: `phoneNumber`, `alternativePhone`, `address`, `city`, `country`.
   - **Validaciones**: Formato válido de teléfono y dirección.

3. **Location**
   - Representa ubicación geográfica.
   - **Atributos**: `latitude`, `longitude`, `altitude`, `region`.
   - **Validaciones**: Coordenadas válidas dentro de rangos permitidos.

4. **UserType**
   - Enumeración de tipos de usuario: `PRODUCER`, `COOPERATIVE`.

#### **Commands**
1. **RegisterProducerCommand**
   - Registra un nuevo productor independiente.
   - **Atributos**: `email`, `password`, `personalInfo`, `farmInfo`.

2. **RegisterCooperativeCommand**
   - Registra una nueva cooperativa.
   - **Atributos**: `email`, `password`, `cooperativeInfo`, `contactInfo`.

3. **UpdateProfileCommand**
   - Actualiza el perfil de un usuario existente.
   - **Atributos**: `userId`, `profileData`.

#### **Queries**
1. **GetUserByIdQuery**
   - Recupera un usuario por su ID.

2. **GetUserByEmailQuery**
   - Recupera un usuario por su email.

3. **GetProducerProfileQuery**
   - Recupera el perfil completo de un productor.

#### **Events**
1. **UserRegisteredEvent**
   - Se dispara cuando se registra un nuevo usuario.
   - **Atributos**: `userId`, `userType`, `email`.

2. **ProfileUpdatedEvent**
   - Se dispara cuando se actualiza un perfil.
   - **Atributos**: `userId`, `updatedFields`.

### 4.2.1.2. Interface Layer

#### **Controllers**
1. **AuthController**
   - **Endpoints**:
     - `POST /api/v1/auth/register/producer`
     - `POST /api/v1/auth/register/cooperative`
     - `POST /api/v1/auth/login`
     - `POST /api/v1/auth/logout`

2. **ProfileController**
   - **Endpoints**:
     - `GET /api/v1/profiles/{userId}`
     - `PUT /api/v1/profiles/{userId}`
     - `GET /api/v1/profiles/producer/{producerId}`
     - `GET /api/v1/profiles/cooperative/{cooperativeId}`

#### **Resources**
1. **RegisterProducerResource**
   - **Atributos**: `email`, `password`, `firstName`, `lastName`, `farmName`, `location`, `hectares`.

2. **UserResource**
   - **Atributos**: `id`, `email`, `userType`, `status`, `profile`.

#### **Transformers**
1. **RegisterProducerCommandFromResourceAssembler**
2. **UserResourceFromEntityAssembler**
3. **ProfileResourceFromEntityAssembler**

### 4.2.1.3. Application Layer

#### **Command Services**
1. **UserCommandServiceImpl**
   - **Métodos**: `handle(RegisterProducerCommand)`, `handle(RegisterCooperativeCommand)`, `handle(UpdateProfileCommand)`
   - **Validaciones**:
     - Email único en el sistema
     - Información de finca válida para productores
     - Capacidad de procesamiento válida para cooperativas

#### **Query Services**
1. **UserQueryServiceImpl**
   - **Métodos**: `handle(GetUserByIdQuery)`, `handle(GetUserByEmailQuery)`

2. **ProfileQueryServiceImpl**
   - **Métodos**: `handle(GetProducerProfileQuery)`, `handle(GetCooperativeProfileQuery)`

### 4.2.1.4. Infrastructure Layer

#### **Persistencia (JPA Repositories)**
1. **UserRepository**
   - `findByEmail(String email)`
   - `existsByEmail(String email)`

2. **ProducerProfileRepository**
   - `findByUserId(Long userId)`

3. **CooperativeProfileRepository**
   - `findByUserId(Long userId)`

#### 4.2.1.5. Bounded Context Software Architecture Component Level Diagrams

[![structurizr-106404-IAMProfile-Component-Diagram.png](https://i.postimg.cc/GpcLQ8Tt/structurizr-106404-IAMProfile-Component-Diagram.png)](https://postimg.cc/G45n3pQn)

### 4.2.1.6.  Bounded Context Software Architecture Code Level Diagrams

En esta sección se presentan los diagramas UML a nivel de código para el contexto determinado.

#### 4.2.1.6.1. Bounded Context Domain Layer Class Diagrams

[![Captura-de-pantalla-2025-09-20-185251.png](https://i.postimg.cc/mgLP82nd/Captura-de-pantalla-2025-09-20-185251.png)](https://postimg.cc/dLfQ0vwd)

#### 4.2.1.6.2. Bounded Context Database Design Diagram

[![Captura-de-pantalla-2025-09-20-185333.png](https://i.postimg.cc/bvdsfVpk/Captura-de-pantalla-2025-09-20-185333.png)](https://postimg.cc/SXFyWrXx)


---

## 4.2.2. Bounded Context: Coffee Lot Management

El **Coffee Lot Management Bounded Context** es responsable de gestionar la información y el ciclo de vida de los lotes de café en el sistema. Este contexto permite a productores y cooperativas registrar, visualizar, editar y eliminar lotes de café, incluyendo detalles como fecha de cosecha, variedad, origen y cantidad.

### 4.2.2.1. Domain Layer

La Domain Layer del Coffee Lot Management Bounded Context encapsula la lógica de negocio relacionada con la gestión del ciclo de vida de los lotes de café, desde su registro inicial hasta su estado final de envío.

#### **Aggregates**
1. **CoffeeLot**
   - **Propósito**: Agregado raíz que encapsula toda la información y reglas de negocio relacionadas con un lote de café.
   - **Atributos**:
     - `lotNumber`: Número único de lote, autogenerado según patrón establecido.
     - `producerId`: Identificador del productor propietario del lote.
     - `harvestDate`: Fecha de cosecha del café, validada como no futura.
     - `coffeeVariety`: Variedad de café cultivada (Typica, Caturra, Bourbon, etc.).
     - `quantity`: Cantidad en kilogramos del lote, debe ser mayor a cero.
     - `status`: Estado actual del lote en el ciclo de vida.
     - `originData`: Información detallada del origen, representada como objeto de valor.
     - `processingMethod`: Método de procesamiento aplicado al café.
   - **Métodos**:
     - `updateQuantity(BigDecimal newQuantity)`: Actualiza cantidad con validaciones.
     - `changeStatus(LotStatus newStatus)`: Cambia estado siguiendo workflow definido.
     - `updateOriginData(OriginData originData)`: Actualiza información de origen.
     - `canBeDeleted()`: Verifica si el lote puede ser eliminado según reglas de negocio.
     - `isReadyForClassification()`: Determina si cumple requisitos para clasificación.
   - **Características**:
     - Extiende `AuditableAbstractAggregateRoot` para trazabilidad completa.
     - Implementa invariantes de negocio para garantizar integridad de datos.

#### **Entities**
1. **OriginData**
   - **Propósito**: Entidad que encapsula información detallada del origen geográfico del lote.
   - **Atributos**:
     - `altitude`: Altitud de cultivo en metros sobre el nivel del mar.
     - `coordinates`: Coordenadas geográficas precisas del cultivo.
     - `soilType`: Tipo de suelo donde se cultivó el café.
     - `climateZone`: Zona climática de cultivo.
     - `farmSection`: Sección específica de la finca donde se cosechó.
   - **Métodos**:
     - `validateCoordinates()`: Valida que las coordenadas estén dentro de rangos geográficos válidos.
     - `isSpecialtyAltitude()`: Determina si la altitud cumple requisitos para café especial.

#### **Value Objects**
1. **LotNumber**
   - Representa el número único de identificación del lote.
   - **Atributos**: `value` (String con formato específico).
   - **Validaciones**: Formato único que incluye código de productor, año y secuencial.
   - **Patrón**: `PROD-YYYY-NNNN` donde PROD es código productor, YYYY es año, NNNN secuencial.

2. **Quantity**
   - Representa la cantidad de café en kilogramos.
   - **Atributos**: `value` (BigDecimal), `unit` (siempre KG).
   - **Validaciones**: Debe ser positivo y no exceder límites razonables por lote.

3. **Coordinates**
   - Representa ubicación geográfica precisa.
   - **Atributos**: `latitude`, `longitude`, `altitude`.
   - **Validaciones**: Coordenadas válidas dentro de rangos de cultivo de café.

4. **LotStatus**
   - Enumeración de estados del lote: `REGISTERED`, `PROCESSING`, `CLASSIFIED`, `CERTIFIED`, `SHIPPED`.
   - **Transiciones válidas**: Define workflow estricto entre estados.

5. **CoffeeVariety**
   - Enumeración de variedades de café: `TYPICA`, `CATURRA`, `BOURBON`, `GEISHA`, `SL28`, `SL34`, etc.

6. **ProcessingMethod**
   - Enumeración de métodos de procesamiento: `WASHED`, `NATURAL`, `HONEY`, `SEMI_WASHED`.

#### **Commands**
1. **RegisterCoffeeLotCommand**
   - Registra un nuevo lote de café en el sistema.
   - **Atributos**: `producerId`, `harvestDate`, `coffeeVariety`, `quantity`, `originData`, `processingMethod`.
   - **Validaciones**: Productor existente, fecha válida, cantidad positiva.

2. **UpdateCoffeeLotCommand**
   - Actualiza información de un lote existente.
   - **Atributos**: `lotId`, `quantity`, `processingMethod`, `originData`.
   - **Restricciones**: No permite cambio una vez iniciada clasificación.

3. **ChangeLotStatusCommand**
   - Cambia el estado de un lote según workflow definido.
   - **Atributos**: `lotId`, `newStatus`, `changeReason`.

4. **DeleteCoffeeLotCommand**
   - Elimina un lote del sistema.
   - **Atributos**: `lotId`, `deletionReason`.
   - **Restricciones**: Solo lotes en estado REGISTERED pueden eliminarse.

#### **Queries**
1. **GetCoffeeLotByIdQuery**
   - Recupera información completa de un lote específico.
   - **Atributos**: `lotId`.

2. **GetCoffeeLotsByProducerQuery**
   - Recupera todos los lotes de un productor específico.
   - **Atributos**: `producerId`, `status` (opcional), `harvestYear` (opcional).

3. **SearchCoffeeLotsQuery**
   - Búsqueda avanzada de lotes por múltiples criterios.
   - **Atributos**: `variety`, `processingMethod`, `altitudeRange`, `harvestDateRange`, `status`.

4. **GetLotTraceabilityQuery**
   - Recupera información completa de trazabilidad de un lote.
   - **Atributos**: `lotNumber`.

#### **Events**
1. **CoffeeLotRegisteredEvent**
   - Se dispara cuando se registra un nuevo lote.
   - **Atributos**: `lotId`, `lotNumber`, `producerId`, `quantity`, `variety`.

2. **CoffeeLotStatusChangedEvent**
   - Se dispara cuando cambia el estado de un lote.
   - **Atributos**: `lotId`, `previousStatus`, `newStatus`, `timestamp`.

3. **CoffeeLotUpdatedEvent**
   - Se dispara cuando se actualiza información del lote.
   - **Atributos**: `lotId`, `updatedFields`, `updatedBy`.

4. **CoffeeLotDeletedEvent**
   - Se dispara cuando se elimina un lote.
   - **Atributos**: `lotId`, `lotNumber`, `deletionReason`.

### 4.2.2.2. Interface Layer

#### **Controllers**
1. **CoffeeLotController**
   - **Endpoints**:
     - `POST /api/v1/coffee-lots` - Registrar nuevo lote
     - `GET /api/v1/coffee-lots/{lotId}` - Obtener lote por ID
     - `PUT /api/v1/coffee-lots/{lotId}` - Actualizar lote
     - `DELETE /api/v1/coffee-lots/{lotId}` - Eliminar lote
     - `PATCH /api/v1/coffee-lots/{lotId}/status` - Cambiar estado
     - `GET /api/v1/coffee-lots/producer/{producerId}` - Lotes por productor
     - `GET /api/v1/coffee-lots/search` - Búsqueda avanzada

2. **LotTraceabilityController**
   - **Endpoints**:
     - `GET /api/v1/traceability/lot/{lotNumber}` - Información completa de trazabilidad

#### **Resources**
1. **RegisterCoffeeLotResource**
   - **Atributos**: `harvestDate`, `coffeeVariety`, `quantity`, `processingMethod`, `altitude`, `latitude`, `longitude`, `soilType`.

2. **CoffeeLotResource**
   - **Atributos**: `id`, `lotNumber`, `producerId`, `harvestDate`, `coffeeVariety`, `quantity`, `status`, `originData`, `processingMethod`, `createdAt`, `updatedAt`.

3. **UpdateCoffeeLotResource**
   - **Atributos**: `quantity`, `processingMethod`, `originData`.

4. **LotStatusChangeResource**
   - **Atributos**: `newStatus`, `changeReason`.

#### **Transformers**
1. **RegisterCoffeeLotCommandFromResourceAssembler**
   - Convierte `RegisterCoffeeLotResource` a `RegisterCoffeeLotCommand`.

2. **CoffeeLotResourceFromEntityAssembler**
   - Convierte entidad `CoffeeLot` a `CoffeeLotResource`.

3. **UpdateCoffeeLotCommandFromResourceAssembler**
   - Convierte `UpdateCoffeeLotResource` a `UpdateCoffeeLotCommand`.

### 4.2.2.3. Application Layer

#### **Command Services**
1. **CoffeeLotCommandServiceImpl**
   - **Métodos**:
     - `handle(RegisterCoffeeLotCommand)`: Registra nuevo lote con validaciones completas.
     - `handle(UpdateCoffeeLotCommand)`: Actualiza lote verificando estado y permisos.
     - `handle(ChangeLotStatusCommand)`: Cambia estado siguiendo workflow definido.
     - `handle(DeleteCoffeeLotCommand)`: Elimina lote con validaciones de integridad.
   - **Validaciones**:
     - Verificación de existencia y permisos del productor.
     - Validación de fechas de cosecha (no futuras, dentro de temporada).
     - Verificación de coordenadas dentro de zonas cafetaleras válidas.
     - Cumplimiento de workflow de estados.
     - Integridad referencial antes de eliminaciones.

#### **Query Services**
1. **CoffeeLotQueryServiceImpl**
   - **Métodos**:
     - `handle(GetCoffeeLotByIdQuery)`: Recupera lote específico con información completa.
     - `handle(GetCoffeeLotsByProducerQuery)`: Lista lotes filtrados por criterios.
     - `handle(SearchCoffeeLotsQuery)`: Búsqueda avanzada con paginación.
     - `handle(GetLotTraceabilityQuery)`: Información completa para trazabilidad.

#### **Domain Services**
1. **LotNumberGeneratorService**
   - **Propósito**: Genera números únicos de lote siguiendo patrón establecido.
   - **Métodos**: `generateLotNumber(Long producerId)`.

2. **LotValidationService**
   - **Propósito**: Centraliza validaciones complejas de reglas de negocio.
   - **Métodos**: 
     - `validateHarvestDate(LocalDate date)`: Valida fecha dentro de temporada cafetalera.
     - `validateCoordinatesForCoffee(Coordinates coords)`: Verifica zonas aptas para café.
     - `canChangeStatus(LotStatus current, LotStatus target)`: Valida transición de estados.

3. **OriginVerificationService**
   - **Propósito**: Verifica autenticidad de información de origen.
   - **Métodos**: `verifyOriginData(OriginData data)`.

### 4.2.2.4. Infrastructure Layer

#### **Persistencia (JPA Repositories)**
1. **CoffeeLotRepository**
   - `findById(Long id)`: Busca lote por ID.
   - `findByLotNumber(String lotNumber)`: Busca por número de lote.
   - `findByProducerId(Long producerId)`: Lotes de un productor específico.
   - `findByProducerIdAndStatus(Long producerId, LotStatus status)`: Filtrado por estado.
   - `findByHarvestDateBetween(LocalDate start, LocalDate end)`: Rango de fechas.
   - `findByCoffeeVariety(CoffeeVariety variety)`: Por variedad de café.
   - `existsByLotNumber(String lotNumber)`: Verifica unicidad de número.
   - `countByProducerIdAndStatus(Long producerId, LotStatus status)`: Conteo por estado.

#### **External Services Integration**
1. **ProducerVerificationService**
   - **Propósito**: Interface para verificar existencia y validez de productores.
   - **Métodos**: `verifyProducerExists(Long producerId)`, `getProducerInfo(Long producerId)`.

2. **GeolocationValidationService**
   - **Propósito**: Servicio externo para validar coordenadas geográficas.
   - **Métodos**: `validateCoffeeGrowingRegion(Coordinates coords)`.

#### **Event Handling**
1. **CoffeeLotEventHandler**
   - **Propósito**: Maneja eventos del dominio para sincronización con otros bounded contexts.
   - **Métodos**:
     - `handle(CoffeeLotRegisteredEvent)`: Notifica registro a contexts relacionados.
     - `handle(CoffeeLotStatusChangedEvent)`: Propaga cambios de estado.

---

### 4.2.2.5. Bounded Context Software Architecture Component Level Diagrams

[![structurizr-106404-Coffee-Lot-Component-Diagram.png](https://i.postimg.cc/JnFRMp6H/structurizr-106404-Coffee-Lot-Component-Diagram.png)](https://postimg.cc/JDjfQ5WR)

### 4.2.2.6.  Bounded Context Software Architecture Code Level Diagrams

En esta sección se presentan los diagramas UML a nivel de código para el contexto determinado.

#### 4.2.2.6.1. Bounded Context Domain Layer Class Diagrams

[![Captura-de-pantalla-2025-09-20-185124.png](https://i.postimg.cc/vmv6GxVw/Captura-de-pantalla-2025-09-20-185124.png)](https://postimg.cc/JyGhqnxp)

#### 4.2.2.6.2. Bounded Context Database Design Diagram

[![Captura-de-pantalla-2025-09-20-185158.png](https://i.postimg.cc/5NvBZ0nb/Captura-de-pantalla-2025-09-20-185158.png)](https://postimg.cc/Czhn8w3Q)


---

## 4.2.3. Bounded Context: Grain Classification

El **Grain Classification Bounded Context** es el corazón del sistema BeanDetect AI, responsable de la clasificación automática de granos de café utilizando inteligencia artificial para el análisis de imágenes por computadora. Este contexto procesa imágenes de granos, detecta defectos y mide parámetros de calidad.

### 4.2.3.1. Domain Layer

La Domain Layer del Grain Classification Bounded Context encapsula la lógica de negocio más compleja del sistema, incluyendo algoritmos de clasificación, detección de defectos y cálculo de métricas de calidad basadas en estándares internacionales del café.

#### **Aggregates**
1. **ClassificationSession**
   - **Propósito**: Agregado raíz que representa una sesión completa de clasificación de un lote de café.
   - **Atributos**:
     - `sessionId`: Identificador único de la sesión, autogenerado.
     - `coffeeLotId`: Referencia al lote de café being classified.
     - `userId`: Usuario que inició la sesión de clasificación.
     - `status`: Estado actual de la sesión (STARTED, IN_PROGRESS, COMPLETED, FAILED).
     - `totalGrainsAnalyzed`: Contador de granos procesados en la sesión.
     - `processingTimeSeconds`: Tiempo total de procesamiento en segundos.
     - `classificationResult`: Resultado consolidado de la clasificación.
     - `defectDetections`: Lista de defectos detectados durante la sesión.
     - `imageAnalysisData`: Metadata del análisis de imágenes.
   - **Métodos**:
     - `startClassification()`: Inicia el proceso de clasificación con validaciones.
     - `addGrainAnalysis(GrainAnalysis analysis)`: Procesa análisis de grano individual.
     - `calculateQualityGrade()`: Calcula grado de calidad según estándares.
     - `completeSession()`: Finaliza sesión y consolida resultados.
     - `failSession(String reason)`: Marca sesión como fallida.
     - `canAddMoreGrains()`: Verifica si se pueden procesar más granos.
   - **Características**:
     - Extiende `AuditableAbstractAggregateRoot` para trazabilidad completa.
     - Implementa invariantes de negocio para mínimo de granos analizados.

2. **ClassificationResult**
   - **Propósito**: Agregado que encapsula los resultados finales de una clasificación.
   - **Atributos**:
     - `overallQualityGrade`: Grado general de calidad (A, B, C, SPECIALTY, PREMIUM).
     - `exportQualityPercentage`: Porcentaje apto para exportación.
     - `defectivePercentage`: Porcentaje de granos defectuosos.
     - `specialtyGrade`: Indicador booleano de grado specialty.
     - `qualityScores`: Puntuaciones detalladas por categoría.
     - `recommendations`: Recomendaciones basadas en análisis.
   - **Métodos**:
     - `calculateExportReadiness()`: Determina si cumple estándares de exportación.
     - `generateQualityReport()`: Genera reporte detallado de calidad.
     - `isSpecialtyGrade()`: Evalúa si cumple criterios de café especial.

#### **Entities**
1. **DefectDetection**
   - **Propósito**: Entidad que representa un defecto específico detectado en un grano.
   - **Atributos**:
     - `defectType`: Tipo de defecto según clasificación SCA.
     - `severity`: Severidad del defecto (LOW, MEDIUM, HIGH, CRITICAL).
     - `confidenceScore`: Nivel de confianza del algoritmo de IA (0.0-1.0).
     - `grainCount`: Número de granos afectados por este defecto.
     - `imageCoordinates`: Coordenadas del defecto en la imagen.
     - `impactOnGrade`: Impacto calculado en el grado final.
   - **Métodos**:
     - `calculateQualityImpact()`: Calcula impacto en calidad general.
     - `isHighConfidence()`: Verifica si supera threshold de confianza.

2. **GrainAnalysis**
   - **Propósito**: Entidad que representa el análisis individual de un grano de café.
   - **Atributos**:
     - `grainId`: Identificador único del grano en la muestra.
     - `size`: Dimensiones del grano (largo, ancho, grosor).
     - `color`: Análisis colorimétrico del grano.
     - `shape`: Características de forma y simetría.
     - `surfaceDefects`: Lista de defectos superficiales detectados.
     - `classification`: Clasificación individual del grano.
   - **Métodos**:
     - `categorizeBySize()`: Clasifica grano por tamaño según estándares.
     - `assessColorUniformity()`: Evalúa uniformidad de color.
     - `detectSurfaceAnomalies()`: Identifica anomalías superficiales.

#### **Value Objects**
1. **SessionId**
   - Representa identificador único de sesión.
   - **Atributos**: `value` (String con formato temporal y secuencial).
   - **Patrón**: `SESS-YYYYMMDD-HHMMSS-XXXX`.

2. **QualityGrade**
   - Enumeración de grados de calidad: `A`, `B`, `C`, `SPECIALTY`, `PREMIUM`.
   - **Características**: Incluye rangos de puntuación asociados (80-100 puntos SCA).

3. **DefectType**
   - Enumeración exhaustiva de tipos de defectos según SCA:
     - `BLACK_BEAN`, `SOUR_BEAN`, `INSECT_DAMAGE`, `BROKEN_BEAN`
     - `HULL_BEAN`, `IMMATURE_BEAN`, `WITHERED_BEAN`, `SHELL_BEAN`
   - **Atributos**: Cada tipo incluye peso de penalización en puntuación final.

4. **ConfidenceScore**
   - Representa nivel de confianza del algoritmo.
   - **Atributos**: `value` (BigDecimal entre 0.0 y 1.0).
   - **Validaciones**: Threshold mínimo de 0.85 para considerarse válido.

5. **ProcessingParameters**
   - Parámetros de configuración para el procesamiento de IA.
   - **Atributos**: `imageResolution`, `contrastLevel`, `colorCalibration`, `algorithmVersion`.

6. **QualityMetrics**
   - Métricas detalladas de calidad calculadas.
   - **Atributos**: `cupping_score`, `aroma_score`, `flavor_score`, `acidity_score`, `body_score`.

#### **Commands**
1. **StartClassificationCommand**
   - Inicia una nueva sesión de clasificación.
   - **Atributos**: `coffeeLotId`, `userId`, `processingParameters`, `sampleSize`.
   - **Validaciones**: Lote existente, usuario autorizado, parámetros válidos.

2. **UploadGrainImagesCommand**
   - Sube imágenes de granos para análisis.
   - **Atributos**: `sessionId`, `imageFiles`, `imageMetadata`.
   - **Restricciones**: Sesión activa, formatos soportados, tamaño límite.

3. **ProcessGrainAnalysisCommand**
   - Procesa análisis de granos individuales.
   - **Atributos**: `sessionId`, `grainAnalyses`, `processingOptions`.

4. **CompleteClassificationCommand**
   - Finaliza sesión y consolida resultados.
   - **Atributos**: `sessionId`, `finalReview`, `qualityNotes`.

5. **RecalibrateModelCommand**
   - Recalibra modelo de IA con nuevos parámetros.
   - **Atributos**: `modelVersion`, `calibrationData`, `validationSample`.

#### **Queries**
1. **GetClassificationSessionQuery**
   - Recupera información completa de sesión.
   - **Atributos**: `sessionId`.

2. **GetClassificationResultsQuery**
   - Obtiene resultados de clasificación por lote.
   - **Atributos**: `coffeeLotId`, `includeDetails`.

3. **GetDefectAnalysisQuery**
   - Análisis detallado de defectos detectados.
   - **Atributos**: `sessionId`, `defectType`, `severityLevel`.

4. **GetQualityTrendsQuery**
   - Tendencias de calidad por productor/temporada.
   - **Atributos**: `producerId`, `timeRange`, `qualityGrade`.

5. **GetModelPerformanceQuery**
   - Métricas de rendimiento del modelo de IA.
   - **Atributos**: `modelVersion`, `timeRange`.

#### **Events**
1. **ClassificationSessionStartedEvent**
   - Se dispara al iniciar nueva sesión.
   - **Atributos**: `sessionId`, `coffeeLotId`, `userId`, `startTime`.

2. **GrainAnalysisCompletedEvent**
   - Se dispara al completar análisis de cada grano.
   - **Atributos**: `sessionId`, `grainId`, `analysisResult`, `processingTime`.

3. **DefectDetectedEvent**
   - Se dispara al detectar defecto significativo.
   - **Atributos**: `sessionId`, `defectType`, `severity`, `confidenceScore`.

4. **ClassificationCompletedEvent**
   - Se dispara al finalizar sesión exitosamente.
   - **Atributos**: `sessionId`, `qualityGrade`, `totalGrains`, `processingTime`.

5. **ModelRecalibrationEvent**
   - Se dispara al actualizar modelo de IA.
   - **Atributos**: `oldVersion`, `newVersion`, `improvementMetrics`.

### 4.2.3.2. Interface Layer

#### **Controllers**
1. **ClassificationController**
   - **Endpoints**:
     - `POST /api/v1/classification/start` - Iniciar nueva clasificación
     - `POST /api/v1/classification/{sessionId}/upload` - Subir imágenes
     - `GET /api/v1/classification/{sessionId}` - Estado de sesión
     - `POST /api/v1/classification/{sessionId}/complete` - Finalizar clasificación
     - `GET /api/v1/classification/{sessionId}/results` - Obtener resultados
     - `GET /api/v1/classification/lot/{lotId}/history` - Historial de clasificaciones

2. **AIModelController**
   - **Endpoints**:
     - `POST /api/v1/ai-model/calibrate` - Calibrar modelo
     - `GET /api/v1/ai-model/performance` - Métricas de rendimiento
     - `GET /api/v1/ai-model/version` - Información de versión actual

3. **QualityAnalysisController**
   - **Endpoints**:
     - `GET /api/v1/quality/defects/{sessionId}` - Análisis de defectos
     - `GET /api/v1/quality/trends/{producerId}` - Tendencias de calidad
     - `GET /api/v1/quality/report/{sessionId}` - Reporte detallado

#### **Resources**
1. **StartClassificationResource**
   - **Atributos**: `coffeeLotId`, `sampleSize`, `processingOptions`, `qualityStandard`.

2. **ClassificationSessionResource**
   - **Atributos**: `sessionId`, `status`, `progress`, `totalGrains`, `processingTime`, `estimatedCompletion`.

3. **ClassificationResultResource**
   - **Atributos**: `sessionId`, `qualityGrade`, `exportPercentage`, `defectivePercentage`, `specialtyGrade`, `detailedScores`.

4. **DefectDetectionResource**
   - **Atributos**: `defectType`, `severity`, `count`, `confidenceScore`, `impactLevel`.

5. **ImageUploadResource**
   - **Atributos**: `images`, `metadata`, `processingPreferences`.

#### **Transformers**
1. **StartClassificationCommandFromResourceAssembler**
   - Convierte `StartClassificationResource` a `StartClassificationCommand`.

2. **ClassificationResultResourceFromEntityAssembler**
   - Convierte entidad `ClassificationResult` a `ClassificationResultResource`.

3. **DefectDetectionResourceFromEntityAssembler**
   - Convierte entidad `DefectDetection` a `DefectDetectionResource`.

### 4.2.3.3. Application Layer

#### **Command Services**
1. **ClassificationCommandServiceImpl**
   - **Métodos**:
     - `handle(StartClassificationCommand)`: Inicia sesión con validaciones de negocio.
     - `handle(UploadGrainImagesCommand)`: Procesa carga de imágenes con validaciones.
     - `handle(ProcessGrainAnalysisCommand)`: Ejecuta análisis de IA en granos.
     - `handle(CompleteClassificationCommand)`: Finaliza y consolida resultados.
   - **Validaciones**:
     - Verificación de lote existente y accesible para usuario.
     - Validación de formatos de imagen y calidad mínima.
     - Verificación de mínimo de granos para clasificación válida (1000 granos).
     - Validación de thresholds de confianza del modelo de IA.

#### **Query Services**
1. **ClassificationQueryServiceImpl**
   - **Métodos**:
     - `handle(GetClassificationSessionQuery)`: Recupera información completa de sesión.
     - `handle(GetClassificationResultsQuery)`: Obtiene resultados con análisis detallado.
     - `handle(GetDefectAnalysisQuery)`: Análisis estadístico de defectos.
     - `handle(GetQualityTrendsQuery)`: Tendencias históricas de calidad.

#### **Domain Services**
1. **AIClassificationService**
   - **Propósito**: Interfaz principal con servicios de IA para análisis de granos.
   - **Métodos**:
     - `analyzeGrainImages(List<Image> images)`: Procesa imágenes con modelos de IA.
     - `detectDefects(GrainImage image)`: Identifica defectos específicos.
     - `calculateQualityScore(List<GrainAnalysis> analyses)`: Calcula puntuación SCA.

2. **QualityGradingService**
   - **Propósito**: Implementa estándares de clasificación SCA/ICO.
   - **Métodos**:
     - `calculateOverallGrade(QualityMetrics metrics)`: Determina grado final.
     - `assessSpecialtyEligibility(ClassificationResult result)`: Evalúa criterios specialty.
     - `generateQualityRecommendations(DefectProfile profile)`: Genera recomendaciones.

3. **DefectAnalysisService**
   - **Propósito**: Análisis especializado de defectos y su impacto.
   - **Métodos**:
     - `categorizeDefects(List<DefectDetection> defects)`: Categoriza por tipo y severidad.
     - `calculateDefectImpact(DefectProfile profile)`: Calcula impacto en calidad.
     - `validateConfidenceThresholds(List<DefectDetection> detections)`: Valida confianza.

4. **ImagePreprocessingService**
   - **Propósito**: Preprocesamiento de imágenes para optimizar análisis de IA.
   - **Métodos**:
     - `normalizeImageQuality(Image image)`: Normaliza iluminación y contraste.
     - `segmentGrains(Image image)`: Separa granos individuales en imagen.
     - `calibrateColorProfile(Image image)`: Calibra perfil de colores.

### 4.2.3.4. Infrastructure Layer

#### **Persistencia (JPA Repositories)**
1. **ClassificationSessionRepository**
   - `findById(Long id)`: Busca sesión por ID.
   - `findBySessionId(String sessionId)`: Busca por identificador único.
   - `findByCoffeeLotId(Long lotId)`: Sesiones de un lote específico.
   - `findByUserIdAndStatus(Long userId, SessionStatus status)`: Sesiones activas por usuario.
   - `findByDateRange(LocalDateTime start, LocalDateTime end)`: Sesiones por período.
   - `countByStatusAndUserId(SessionStatus status, Long userId)`: Conteo de sesiones.

2. **DefectDetectionRepository**
   - `findBySessionId(Long sessionId)`: Defectos de una sesión específica.
   - `findByDefectTypeAndSeverity(DefectType type, Severity severity)`: Filtros específicos.
   - `countByDefectTypeGrouped()`: Estadísticas agrupadas por tipo.
   - `findHighConfidenceDetections(BigDecimal threshold)`: Detecciones confiables.

#### **External Services Integration**
1. **AIModelService**
   - **Propósito**: Interface con servicios externos de IA (TensorFlow/PyTorch).
   - **Métodos**:
     - `processImageBatch(List<Image> images)`: Procesa lote de imágenes.
     - `getModelVersion()`: Obtiene versión actual del modelo.
     - `updateModelWeights(ModelWeights weights)`: Actualiza pesos del modelo.

2. **ImageStorageService**
   - **Propósito**: Gestión de almacenamiento de imágenes en la nube.
   - **Métodos**:
     - `storeImage(Image image, String sessionId)`: Almacena imagen.
     - `retrieveImage(String imageId)`: Recupera imagen almacenada.
     - `deleteSessionImages(String sessionId)`: Limpia imágenes de sesión.

3. **CoffeeLotVerificationService**
   - **Propósito**: Verifica existencia y estado de lotes de café.
   - **Métodos**:
     - `verifyLotExists(Long lotId)`: Verifica existencia del lote.
     - `isLotReadyForClassification(Long lotId)`: Verifica estado apropiado.

#### **Event Handling**
1. **ClassificationEventHandler**
   - **Propósito**: Maneja eventos de clasificación para integración con otros contexts.
   - **Métodos**:
     - `handle(ClassificationCompletedEvent)`: Notifica completación a Traceability.
     - `handle(DefectDetectedEvent)`: Alerta sistemas de calidad.
     - `handle(ModelRecalibrationEvent)`: Actualiza configuraciones dependientes.

### 4.2.3.5. Bounded Context Software Architecture Component Level Diagrams

[![structurizr-106404-Grain-Classification-Component-Diagram.png](https://i.postimg.cc/W3zsBBnP/structurizr-106404-Grain-Classification-Component-Diagram.png)](https://postimg.cc/WFRRrfC9)

### 4.2.3.6.  Bounded Context Software Architecture Code Level Diagrams

En esta sección se presentan los diagramas UML a nivel de código para el contexto determinado.

#### 4.2.3.6.1. Bounded Context Domain Layer Class Diagrams

[![Captura-de-pantalla-2025-09-20-184956.png](https://i.postimg.cc/yx8mMXQG/Captura-de-pantalla-2025-09-20-184956.png)](https://postimg.cc/hzNQxxq8)

#### 4.2.3.6.2. Bounded Context Database Design Diagram

[![Captura-de-pantalla-2025-09-20-185024.png](https://i.postimg.cc/PqnmXkVY/Captura-de-pantalla-2025-09-20-185024.png)](https://postimg.cc/qNQtwWTv)


---

## 4.2.4. Bounded Context: Traceability & Certification

El **Traceability & Certification Bounded Context** es responsable de proporcionar trazabilidad y certificación digital para los lotes de café en el sistema BeanDetect AI. Este contexto garantiza la transparencia, confianza e inmutabilidad de los registros mediante tecnología blockchain, generando certificados digitales, códigos QR y manteniendo registros auditables desde el origen hasta el consumidor final.

### 4.2.4.1. Domain Layer

La Domain Layer del Traceability & Certification Bounded Context encapsula la lógica de negocio relacionada con la trazabilidad completa, certificación digital y verificación de autenticidad de los lotes de café según estándares internacionales de comercio justo y sostenibilidad.

#### **Aggregates**
1. **TraceabilityRecord**
   - **Propósito**: Agregado raíz que encapsula el registro completo de trazabilidad de un lote de café.
   - **Atributos**:
     - `recordId`: Identificador único del registro de trazabilidad.
     - `coffeeLotId`: Referencia al lote de café siendo trazado.
     - `qrCode`: Código QR único generado para verificación instantánea.
     - `blockchainHash`: Hash de transacción en blockchain para inmutabilidad.
     - `journeyStages`: Etapas del viaje del café (cultivo, procesamiento, clasificación, certificación).
     - `verificationStatus`: Estado de verificación del registro.
     - `digitalSignature`: Firma digital del registro para autenticidad.
   - **Métodos**:
     - `generateQRCode()`: Genera código QR único con información embebida.
     - `recordToBlockchain()`: Registra información inmutable en blockchain.
     - `addJourneyStage(JourneyStage stage)`: Agrega nueva etapa al viaje.
     - `verifyIntegrity()`: Verifica integridad del registro completo.
     - `generateTraceabilityReport()`: Genera reporte completo de trazabilidad.
   - **Características**:
     - Extiende `AuditableAbstractAggregateRoot` para trazabilidad completa.
     - Implementa criptografía para garantizar inmutabilidad.

2. **Certificate**
   - **Propósito**: Agregado que representa un certificado digital específico para un lote de café.
   - **Atributos**:
     - `certificateId`: Identificador único del certificado.
     - `coffeeLotId`: Lote al cual pertenece el certificado.
     - `certificationType`: Tipo de certificación (ORGANIC, FAIR_TRADE, RAINFOREST, etc.).
     - `certificateName`: Nombre oficial del certificado.
     - `issuingBody`: Organismo certificador oficial.
     - `certificationNumber`: Número oficial de certificación.
     - `issueDate`: Fecha de emisión del certificado.
     - `expiryDate`: Fecha de expiración del certificado.
     - `digitalCertificate`: Documento PDF digital firmado.
     - `verificationQR`: QR específico para verificar autenticidad.
   - **Métodos**:
     - `validateCertificationRequirements()`: Valida cumplimiento de requisitos.
     - `generateDigitalCertificate()`: Crea documento PDF firmado digitalmente.
     - `renewCertificate()`: Renueva certificado antes del vencimiento.
     - `revokeCertificate(String reason)`: Revoca certificado por causa justificada.
     - `isValid()`: Verifica vigencia y validez del certificado.

#### **Entities**
1. **JourneyStage**
   - **Propósito**: Entidad que representa una etapa específica en el viaje del café.
   - **Atributos**:
     - `stageType`: Tipo de etapa (CULTIVATION, HARVESTING, PROCESSING, CLASSIFICATION, CERTIFICATION, SHIPPING).
     - `timestamp`: Momento exacto de la etapa.
     - `location`: Ubicación geográfica donde ocurrió la etapa.
     - `responsibleParty`: Parte responsable de esta etapa.
     - `stageData`: Datos específicos de la etapa.
     - `verificationProof`: Prueba de verificación de la etapa.
   - **Métodos**:
     - `validateStageSequence()`: Valida orden correcto de etapas.
     - `generateStageProof()`: Genera prueba criptográfica de la etapa.

2. **OriginVerification**
   - **Propósito**: Entidad que verifica autenticidad del origen geográfico.
   - **Atributos**:
     - `farmCoordinates`: Coordenadas exactas de la finca.
     - `altitudeRange`: Rango de altitud de cultivo.
     - `soilAnalysis`: Análisis de suelo certificado.
     - `climateData`: Datos climáticos del período de cultivo.
     - `satelliteImagery`: Imágenes satelitales para verificación.
   - **Métodos**:
     - `verifySatelliteData()`: Verifica datos con imágenes satelitales.
     - `validateGrowingConditions()`: Valida condiciones de cultivo.

#### **Value Objects**
1. **QRCode**
   - Representa código QR único para trazabilidad.
   - **Atributos**: `value` (String codificado), `embeddedData` (información integrada).
   - **Validaciones**: Unicidad global, formato estándar QR.

2. **BlockchainHash**
   - Representa hash inmutable en blockchain.
   - **Atributos**: `value` (String hash criptográfico), `blockNumber`, `transactionId`.
   - **Características**: Inmutable una vez registrado en blockchain.

3. **CertificationType**
   - Enumeración de tipos de certificación disponibles:
     - `ORGANIC`, `FAIR_TRADE`, `RAINFOREST_ALLIANCE`, `UTZ_CERTIFIED`, `BIRD_FRIENDLY`
   - **Atributos**: Cada tipo incluye requisitos específicos y organismos certificadores.

4. **DigitalSignature**
   - Firma digital criptográfica para autenticidad.
   - **Atributos**: `signature` (String), `algorithm`, `publicKey`, `timestamp`.
   - **Validaciones**: Verificación criptográfica de integridad.

5. **VerificationStatus**
   - Estado de verificación: `PENDING`, `VERIFIED`, `REJECTED`, `EXPIRED`.

6. **IssuingBody**
   - Organismo certificador oficial.
   - **Atributos**: `name`, `accreditationNumber`, `country`, `contactInfo`.

#### **Commands**
1. **CreateTraceabilityRecordCommand**
   - Crea nuevo registro de trazabilidad para un lote.
   - **Atributos**: `coffeeLotId`, `originData`, `initialStages`.
   - **Validaciones**: Lote existente, datos de origen válidos.

2. **GenerateCertificateCommand**
   - Genera certificado digital para un lote específico.
   - **Atributos**: `coffeeLotId`, `certificationType`, `qualificationData`, `issuingBodyId`.
   - **Restricciones**: Cumplimiento de requisitos mínimos de calidad.

3. **RecordJourneyStageCommand**
   - Registra nueva etapa en el viaje del café.
   - **Atributos**: `traceabilityRecordId`, `stageType`, `stageData`, `location`, `timestamp`.

4. **VerifyOriginCommand**
   - Verifica autenticidad del origen mediante múltiples fuentes.
   - **Atributos**: `traceabilityRecordId`, `verificationSources`, `satelliteData`.

5. **RenewCertificateCommand**
   - Renueva certificado antes de su expiración.
   - **Atributos**: `certificateId`, `renewalData`, `updatedRequirements`.

#### **Queries**
1. **GetTraceabilityRecordQuery**
   - Recupera registro completo de trazabilidad.
   - **Atributos**: `recordId` o `qrCode`.

2. **GetCertificatesByLotQuery**
   - Obtiene todos los certificados de un lote específico.
   - **Atributos**: `coffeeLotId`, `includeExpired`.

3. **VerifyQRCodeQuery**
   - Verifica autenticidad mediante código QR.
   - **Atributos**: `qrCode`, `verificationLevel`.

4. **GetJourneyHistoryQuery**
   - Recupera historial completo del viaje del café.
   - **Atributos**: `traceabilityRecordId`, `includeProofs`.

5. **ValidateCertificateQuery**
   - Valida autenticidad y vigencia de certificado.
   - **Atributos**: `certificateId` o `certificationNumber`.

#### **Events**
1. **TraceabilityRecordCreatedEvent**
   - Se dispara al crear nuevo registro de trazabilidad.
   - **Atributos**: `recordId`, `coffeeLotId`, `qrCode`, `timestamp`.

2. **CertificateIssuedEvent**
   - Se dispara al emitir nuevo certificado.
   - **Atributos**: `certificateId`, `certificationType`, `coffeeLotId`, `issuingBody`.

3. **JourneyStageRecordedEvent**
   - Se dispara al registrar nueva etapa del viaje.
   - **Atributos**: `recordId`, `stageType`, `location`, `timestamp`.

4. **BlockchainTransactionCompletedEvent**
   - Se dispara al completar transacción en blockchain.
   - **Atributos**: `recordId`, `blockchainHash`, `blockNumber`.

5. **CertificateRevokedEvent**
   - Se dispara al revocar un certificado.
   - **Atributos**: `certificateId`, `revocationReason`, `timestamp`.

### 4.2.4.2. Interface Layer

#### **Controllers**
1. **TraceabilityController**
   - **Endpoints**:
     - `POST /api/v1/traceability/create` - Crear registro de trazabilidad
     - `GET /api/v1/traceability/{recordId}` - Obtener registro completo
     - `GET /api/v1/traceability/qr/{qrCode}` - Verificar por QR
     - `POST /api/v1/traceability/{recordId}/stage` - Registrar etapa
     - `GET /api/v1/traceability/{recordId}/journey` - Historial del viaje

2. **CertificationController**
   - **Endpoints**:
     - `POST /api/v1/certification/generate` - Generar certificado
     - `GET /api/v1/certification/{certificateId}` - Obtener certificado
     - `GET /api/v1/certification/lot/{lotId}` - Certificados por lote
     - `POST /api/v1/certification/{certificateId}/renew` - Renovar certificado
     - `POST /api/v1/certification/{certificateId}/revoke` - Revocar certificado

3. **VerificationController**
   - **Endpoints**:
     - `POST /api/v1/verification/qr` - Verificar código QR
     - `POST /api/v1/verification/certificate` - Validar certificado
     - `GET /api/v1/verification/blockchain/{hash}` - Verificar en blockchain

#### **Resources**
1. **CreateTraceabilityResource**
   - **Atributos**: `coffeeLotId`, `farmCoordinates`, `altitudeRange`, `cultivationData`.

2. **TraceabilityRecordResource**
   - **Atributos**: `recordId`, `qrCode`, `blockchainHash`, `journeyStages`, `verificationStatus`.

3. **CertificateGenerationResource**
   - **Atributos**: `coffeeLotId`, `certificationType`, `issuingBodyId`, `qualificationEvidence`.

4. **CertificateResource**
   - **Atributos**: `certificateId`, `certificationType`, `issuingBody`, `issueDate`, `expiryDate`, `isValid`.

5. **QRVerificationResource**
   - **Atributos**: `qrCode`, `verificationLevel`, `includeJourney`.

#### **Transformers**
1. **CreateTraceabilityCommandFromResourceAssembler**
   - Convierte `CreateTraceabilityResource` a `CreateTraceabilityRecordCommand`.

2. **TraceabilityRecordResourceFromEntityAssembler**
   - Convierte entidad `TraceabilityRecord` a `TraceabilityRecordResource`.

3. **CertificateResourceFromEntityAssembler**
   - Convierte entidad `Certificate` a `CertificateResource`.

### 4.2.4.3. Application Layer

#### **Command Services**
1. **TraceabilityCommandServiceImpl**
   - **Métodos**:
     - `handle(CreateTraceabilityRecordCommand)`: Crea registro con validaciones.
     - `handle(RecordJourneyStageCommand)`: Registra etapa con verificaciones.
     - `handle(VerifyOriginCommand)`: Verifica origen con múltiples fuentes.
   - **Validaciones**:
     - Verificación de existencia del lote de café.
     - Validación de coordenadas geográficas en zonas cafetaleras.
     - Verificación de secuencia correcta de etapas del viaje.

2. **CertificationCommandServiceImpl**
   - **Métodos**:
     - `handle(GenerateCertificateCommand)`: Genera certificado con validaciones.
     - `handle(RenewCertificateCommand)`: Renueva certificado existente.
     - `handle(RevokeCertificateCommand)`: Revoca certificado por causas justificadas.
   - **Validaciones**:
     - Verificación de cumplimiento de requisitos de certificación.
     - Validación de autoridad del organismo certificador.
     - Verificación de calidad mínima para tipo de certificación.

#### **Query Services**
1. **TraceabilityQueryServiceImpl**
   - **Métodos**:
     - `handle(GetTraceabilityRecordQuery)`: Recupera registro completo.
     - `handle(GetJourneyHistoryQuery)`: Historial detallado del viaje.
     - `handle(VerifyQRCodeQuery)`: Verificación instantánea por QR.

2. **CertificationQueryServiceImpl**
   - **Métodos**:
     - `handle(GetCertificatesByLotQuery)`: Certificados de un lote.
     - `handle(ValidateCertificateQuery)`: Validación de autenticidad.

#### **Domain Services**
1. **BlockchainIntegrationService**
   - **Propósito**: Integración con red blockchain para inmutabilidad.
   - **Métodos**:
     - `recordTransaction(TraceabilityData data)`: Registra transacción inmutable.
     - `verifyBlockchainIntegrity(String hash)`: Verifica integridad en blockchain.
     - `getTransactionDetails(String hash)`: Obtiene detalles de transacción.

2. **QRCodeGenerationService**
   - **Propósito**: Generación de códigos QR únicos con información embebida.
   - **Métodos**:
     - `generateUniqueQR(TraceabilityRecord record)`: Genera QR con datos embebidos.
     - `decodeQRInformation(String qrCode)`: Decodifica información del QR.

3. **DigitalSignatureService**
   - **Propósito**: Firma digital de certificados para autenticidad.
   - **Métodos**:
     - `signCertificate(Certificate certificate)`: Firma digitalmente.
     - `verifySignature(Certificate certificate)`: Verifica autenticidad.

4. **OriginVerificationService**
   - **Propósito**: Verificación de autenticidad del origen geográfico.
   - **Métodos**:
     - `verifySatelliteImagery(Coordinates coords)`: Verifica con imágenes satelitales.
     - `validateClimateData(OriginData data)`: Valida datos climáticos.

### 4.2.4.4. Infrastructure Layer

#### **Persistencia (JPA Repositories)**
1. **TraceabilityRecordRepository**
   - `findById(Long id)`: Busca registro por ID.
   - `findByQrCode(String qrCode)`: Busca por código QR.
   - `findByCoffeeLotId(Long lotId)`: Registro de lote específico.
   - `findByBlockchainHash(String hash)`: Busca por hash blockchain.
   - `findByVerificationStatus(VerificationStatus status)`: Por estado.

2. **CertificateRepository**
   - `findById(Long id)`: Busca certificado por ID.
   - `findByCertificateId(String certificateId)`: Por ID único.
   - `findByCoffeeLotId(Long lotId)`: Certificados de un lote.
   - `findByCertificationType(CertificationType type)`: Por tipo.
   - `findByIssuingBody(String issuingBody)`: Por organismo certificador.
   - `findActiveByLotId(Long lotId)`: Certificados vigentes.

#### **External Services Integration**
1. **BlockchainNetworkService**
   - **Propósito**: Interface con red blockchain externa.
   - **Métodos**:
     - `submitTransaction(TransactionData data)`: Envía transacción.
     - `queryTransaction(String hash)`: Consulta transacción.
     - `getNetworkStatus()`: Estado de la red blockchain.

2. **SatelliteImageryService**
   - **Propósito**: Integración con servicios de imágenes satelitales.
   - **Métodos**:
     - `getImageryData(Coordinates coords, DateRange period)`: Obtiene imágenes.
     - `analyzeVegetationIndex(ImageryData data)`: Analiza índices de vegetación.

3. **ClassificationResultService**
   - **Propósito**: Obtiene resultados de clasificación para certificación.
   - **Métodos**:
     - `getQualityResults(Long lotId)`: Resultados de calidad.
     - `validateCertificationEligibility(QualityResults results)`: Valida elegibilidad.

#### **Event Handling**
1. **TraceabilityEventHandler**
   - **Propósito**: Maneja eventos de trazabilidad para integración.
   - **Métodos**:
     - `handle(CoffeeLotClassifiedEvent)`: Registra etapa de clasificación.
     - `handle(CertificateIssuedEvent)`: Actualiza estado de trazabilidad.

### 4.2.4.5. Bounded Context Software Architecture Component Level Diagrams

[![structurizr-106404-Traceability-Component-Diagram.png](https://i.postimg.cc/jS6qPQ5B/structurizr-106404-Traceability-Component-Diagram.png)](https://postimg.cc/nXzttmq1)

### 4.2.4.6.  Bounded Context Software Architecture Code Level Diagrams

En esta sección se presentan los diagramas UML a nivel de código para el contexto determinado.

#### 4.2.4.6.1. Bounded Context Domain Layer Class Diagrams

[![Captura-de-pantalla-2025-09-20-184806.png](https://i.postimg.cc/G3KzX97N/Captura-de-pantalla-2025-09-20-184806.png)](https://postimg.cc/Yj4192wf)

#### 4.2.4.6.2. Bounded Context Database Design Diagram

[![Captura-de-pantalla-2025-09-20-184712.png](https://i.postimg.cc/xCKpfRPT/Captura-de-pantalla-2025-09-20-184712.png)](https://postimg.cc/FdHVG0q2)

---

## 4.2.5. Bounded Context: Reporting & Analytics

El **Reporting & Analytics Bounded Context** es responsable de transformar datos operacionales en insights accionables para productores y cooperativas en el sistema BeanDetect AI. Este contexto genera reportes comprehensivos, análisis de tendencias, dashboards interactivos y alertas automáticas basadas en métricas de calidad, rendimiento de cosecha y patrones históricos de producción cafetalera.

### 4.2.5.1. Domain Layer

La Domain Layer del Reporting & Analytics Bounded Context encapsula la lógica de negocio relacionada con la generación de reportes, cálculo de métricas agregadas, análisis de tendencias y generación de insights para la toma de decisiones en la industria cafetalera.

#### **Aggregates**
1. **Report**
   - **Propósito**: Agregado raíz que representa un reporte generado para un período y tipo específico.
   - **Atributos**:
     - `reportId`: Identificador único del reporte.
     - `producerId`: Productor o cooperativa para quien se genera el reporte.
     - `reportType`: Tipo de reporte (QUALITY, HARVEST, CERTIFICATION, COMPARATIVE).
     - `title`: Título descriptivo del reporte.
     - `periodStart`: Fecha de inicio del período analizado.
     - `periodEnd`: Fecha de fin del período analizado.
     - `reportStatus`: Estado del reporte (GENERATING, COMPLETED, FAILED).
     - `reportData`: Datos consolidados del reporte.
     - `visualizations`: Gráficos y visualizaciones incluidas.
     - `insights`: Insights y recomendaciones generadas.
   - **Métodos**:
     - `generateReport()`: Inicia proceso de generación con validaciones.
     - `addReportSection(ReportSection section)`: Agrega sección al reporte.
     - `calculateKPIs()`: Calcula indicadores clave de rendimiento.
     - `generateInsights()`: Genera insights basados en datos históricos.
     - `exportToPDF()`: Genera versión PDF del reporte.
     - `scheduleDelivery(DeliverySchedule schedule)`: Programa entrega automática.
   - **Características**:
     - Extiende `AuditableAbstractAggregateRoot` para trazabilidad.
     - Implementa patrones de generación asíncrona de reportes.

2. **QualityMetrics**
   - **Propósito**: Agregado que consolida métricas de calidad agregadas por productor y período.
   - **Atributos**:
     - `metricsId`: Identificador único de las métricas.
     - `producerId`: Productor asociado a las métricas.
     - `metricDate`: Fecha de las métricas (agregación diaria).
     - `lotsProcessed`: Número total de lotes procesados.
     - `totalQuantityKg`: Cantidad total en kilogramos.
     - `averageQualityGrade`: Grado promedio de calidad.
     - `exportPercentage`: Porcentaje apto para exportación.
     - `defectRate`: Tasa de defectos promedio.
     - `specialtyPercentage`: Porcentaje de café specialty.
     - `trendIndicators`: Indicadores de tendencia calculados.
   - **Métodos**:
     - `calculateTrends()`: Calcula tendencias comparadas con períodos anteriores.
     - `updateMetrics(ClassificationResult result)`: Actualiza métricas con nueva clasificación.
     - `generateQualityAlert()`: Genera alerta si métricas están por debajo de thresholds.
     - `compareWithBenchmark()`: Compara con benchmarks de la industria.

#### **Entities**
1. **ReportSection**
   - **Propósito**: Entidad que representa una sección específica dentro de un reporte.
   - **Atributos**:
     - `sectionType`: Tipo de sección (SUMMARY, QUALITY_ANALYSIS, TRENDS, RECOMMENDATIONS).
     - `title`: Título de la sección.
     - `content`: Contenido generado de la sección.
     - `visualizations`: Gráficos asociados a la sección.
     - `dataPoints`: Puntos de datos utilizados.
   - **Métodos**:
     - `generateContent()`: Genera contenido basado en datos disponibles.
     - `addVisualization(Chart chart)`: Agrega visualización a la sección.

2. **Dashboard**
   - **Propósito**: Entidad que representa un dashboard interactivo personalizado.
   - **Atributos**:
     - `dashboardId`: Identificador único del dashboard.
     - `userId`: Usuario propietario del dashboard.
     - `widgets`: Lista de widgets configurados.
     - `refreshInterval`: Intervalo de actualización automática.
     - `layout`: Configuración de layout del dashboard.
   - **Métodos**:
     - `addWidget(Widget widget)`: Agrega widget al dashboard.
     - `refreshData()`: Actualiza datos de todos los widgets.
     - `customizeLayout()`: Personaliza disposición de elementos.

3. **TrendAnalysis**
   - **Propósito**: Entidad que encapsula análisis de tendencias temporales.
   - **Atributos**:
     - `analysisType`: Tipo de análisis (QUALITY_TREND, VOLUME_TREND, DEFECT_TREND).
     - `timeSeriesData`: Datos de series temporales.
     - `trendDirection`: Dirección de la tendencia (UPWARD, DOWNWARD, STABLE).
     - `seasonalPatterns`: Patrones estacionales identificados.
     - `correlations`: Correlaciones encontradas con otros factores.
   - **Métodos**:
     - `calculateTrendLine()`: Calcula línea de tendencia estadística.
     - `identifySeasonalPatterns()`: Identifica patrones estacionales.
     - `generateForecast()`: Genera pronósticos basados en tendencias.

#### **Value Objects**
1. **ReportId**
   - Representa identificador único de reporte.
   - **Atributos**: `value` (String con formato temporal y tipo).
   - **Patrón**: `RPT-TYPE-YYYYMMDD-HHMMSS`.

2. **ReportType**
   - Enumeración de tipos de reporte:
     - `QUALITY_SUMMARY`, `HARVEST_PERFORMANCE`, `CERTIFICATION_STATUS`, `COMPARATIVE_ANALYSIS`.

3. **KPI**
   - Indicador clave de rendimiento.
   - **Atributos**: `name`, `value`, `unit`, `target`, `status`.
   - **Métodos**: `calculatePerformance()`, `isOnTarget()`.

4. **MetricsPeriod**
   - Período de tiempo para agregación de métricas.
   - **Atributos**: `startDate`, `endDate`, `granularity` (DAILY, WEEKLY, MONTHLY, SEASONAL).

5. **TrendDirection**
   - Enumeración de direcciones de tendencia: `IMPROVING`, `DECLINING`, `STABLE`, `VOLATILE`.

6. **VisualizationType**
   - Tipos de visualización: `LINE_CHART`, `BAR_CHART`, `PIE_CHART`, `HEAT_MAP`, `GAUGE`.

#### **Commands**
1. **GenerateReportCommand**
   - Inicia generación de reporte para período específico.
   - **Atributos**: `producerId`, `reportType`, `periodStart`, `periodEnd`, `includeComparisons`.
   - **Validaciones**: Usuario autorizado, período válido, datos disponibles.

2. **UpdateQualityMetricsCommand**
   - Actualiza métricas de calidad con nueva información.
   - **Atributos**: `producerId`, `classificationResults`, `metricDate`.

3. **CreateDashboardCommand**
   - Crea dashboard personalizado para usuario.
   - **Atributos**: `userId`, `dashboardName`, `initialWidgets`, `layoutConfig`.

4. **ScheduleReportCommand**
   - Programa generación automática de reportes.
   - **Atributos**: `reportConfig`, `schedule`, `deliveryMethod`, `recipients`.

5. **GenerateAlertCommand**
   - Genera alerta basada en métricas que superan thresholds.
   - **Atributos**: `alertType`, `threshold`, `currentValue`, `affectedEntity`.

#### **Queries**
1. **GetReportQuery**
   - Recupera reporte específico con todos sus datos.
   - **Atributos**: `reportId`, `includeRawData`.

2. **GetQualityMetricsQuery**
   - Obtiene métricas de calidad para período específico.
   - **Atributos**: `producerId`, `dateRange`, `granularity`.

3. **GetTrendAnalysisQuery**
   - Recupera análisis de tendencias calculadas.
   - **Atributos**: `producerId`, `metricType`, `timeRange`.

4. **GetDashboardDataQuery**
   - Obtiene datos actualizados para dashboard.
   - **Atributos**: `dashboardId`, `refreshTimestamp`.

5. **GetComparativeAnalysisQuery**
   - Análisis comparativo entre productores o períodos.
   - **Atributos**: `baselineEntity`, `comparisonEntities`, `metrics`.

#### **Events**
1. **ReportGeneratedEvent**
   - Se dispara al completar generación de reporte.
   - **Atributos**: `reportId`, `producerId`, `reportType`, `generationTime`.

2. **QualityMetricsUpdatedEvent**
   - Se dispara al actualizar métricas de calidad.
   - **Atributos**: `producerId`, `metricDate`, `updatedMetrics`.

3. **QualityAlertTriggeredEvent**
   - Se dispara cuando métricas superan thresholds de alerta.
   - **Atributos**: `alertType`, `producerId`, `threshold`, `currentValue`.

4. **TrendAnalysisCompletedEvent**
   - Se dispara al completar análisis de tendencias.
   - **Atributos**: `analysisId`, `trendDirection`, `forecast`.

### 4.2.5.2. Interface Layer

#### **Controllers**
1. **ReportController**
   - **Endpoints**:
     - `POST /api/v1/reports/generate` - Generar nuevo reporte
     - `GET /api/v1/reports/{reportId}` - Obtener reporte específico
     - `GET /api/v1/reports/producer/{producerId}` - Reportes por productor
     - `POST /api/v1/reports/{reportId}/export` - Exportar reporte
     - `POST /api/v1/reports/schedule` - Programar reporte automático

2. **AnalyticsController**
   - **Endpoints**:
     - `GET /api/v1/analytics/metrics/{producerId}` - Métricas de calidad
     - `GET /api/v1/analytics/trends/{producerId}` - Análisis de tendencias
     - `GET /api/v1/analytics/comparison` - Análisis comparativo
     - `GET /api/v1/analytics/benchmarks` - Benchmarks de industria

3. **DashboardController**
   - **Endpoints**:
     - `POST /api/v1/dashboards` - Crear dashboard
     - `GET /api/v1/dashboards/{dashboardId}` - Obtener dashboard
     - `PUT /api/v1/dashboards/{dashboardId}` - Actualizar configuración
     - `GET /api/v1/dashboards/{dashboardId}/data` - Datos del dashboard

#### **Resources**
1. **GenerateReportResource**
   - **Atributos**: `reportType`, `periodStart`, `periodEnd`, `includeComparisons`, `deliveryFormat`.

2. **ReportResource**
   - **Atributos**: `reportId`, `title`, `reportType`, `period`, `status`, `downloadUrl`, `insights`.

3. **QualityMetricsResource**
   - **Atributos**: `producerId`, `metricDate`, `lotsProcessed`, `averageGrade`, `exportPercentage`, `trendIndicators`.

4. **DashboardResource**
   - **Atributos**: `dashboardId`, `widgets`, `layout`, `lastUpdated`, `refreshInterval`.

5. **TrendAnalysisResource**
   - **Atributos**: `metricType`, `trendDirection`, `forecast`, `seasonalPatterns`, `correlations`.

#### **Transformers**
1. **GenerateReportCommandFromResourceAssembler**
   - Convierte `GenerateReportResource` a `GenerateReportCommand`.

2. **ReportResourceFromEntityAssembler**
   - Convierte entidad `Report` a `ReportResource`.

3. **QualityMetricsResourceFromEntityAssembler**
   - Convierte entidad `QualityMetrics` a `QualityMetricsResource`.

### 4.2.5.3. Application Layer

#### **Command Services**
1. **ReportCommandServiceImpl**
   - **Métodos**:
     - `handle(GenerateReportCommand)`: Genera reporte con validaciones y procesamiento asíncrono.
     - `handle(ScheduleReportCommand)`: Configura generación automática de reportes.
     - `handle(UpdateQualityMetricsCommand)`: Actualiza métricas agregadas.
   - **Validaciones**:
     - Verificación de autorización del usuario para generar reportes.
     - Validación de disponibilidad de datos para el período solicitado.
     - Verificación de límites de generación de reportes por usuario.

#### **Query Services**
1. **ReportQueryServiceImpl**
   - **Métodos**:
     - `handle(GetReportQuery)`: Recupera reporte con todos los datos asociados.
     - `handle(GetQualityMetricsQuery)`: Obtiene métricas agregadas con cálculos.

2. **AnalyticsQueryServiceImpl**
   - **Métodos**:
     - `handle(GetTrendAnalysisQuery)`: Ejecuta análisis de tendencias complejas.
     - `handle(GetComparativeAnalysisQuery)`: Genera comparaciones multi-dimensionales.

#### **Domain Services**
1. **ReportGenerationService**
   - **Propósito**: Servicio principal para generación de reportes complejos.
   - **Métodos**:
     - `generateQualityReport(ReportParams params)`: Genera reporte de calidad.
     - `generateHarvestReport(ReportParams params)`: Genera reporte de cosecha.
     - `generateComparativeReport(ComparisonParams params)`: Genera análisis comparativo.

2. **TrendAnalysisService**
   - **Propósito**: Análisis estadístico de tendencias y patrones.
   - **Métodos**:
     - `calculateQualityTrends(TimeSeries data)`: Calcula tendencias de calidad.
     - `identifySeasonalPatterns(TimeSeries data)`: Identifica patrones estacionales.
     - `generateForecasts(TrendData data)`: Genera pronósticos basados en tendencias.

3. **KPICalculationService**
   - **Propósito**: Cálculo de indicadores clave de rendimiento.
   - **Métodos**:
     - `calculateProductivityKPIs(ProductionData data)`: KPIs de productividad.
     - `calculateQualityKPIs(QualityData data)`: KPIs de calidad.
     - `calculateEfficiencyKPIs(OperationalData data)`: KPIs de eficiencia.

4. **AlertRuleEngine**
   - **Propósito**: Motor de reglas para generación automática de alertas.
   - **Métodos**:
     - `evaluateQualityRules(QualityMetrics metrics)`: Evalúa reglas de calidad.
     - `checkThresholds(MetricValue value)`: Verifica thresholds configurados.
     - `generateAlert(AlertCondition condition)`: Genera alerta apropiada.

### 4.2.5.4. Infrastructure Layer

#### **Persistencia (JPA Repositories)**
1. **ReportRepository**
   - `findById(Long id)`: Busca reporte por ID.
   - `findByProducerId(Long producerId)`: Reportes de un productor.
   - `findByReportType(ReportType type)`: Reportes por tipo.
   - `findByPeriodRange(LocalDate start, LocalDate end)`: Reportes por período.
   - `findScheduledReports()`: Reportes programados para generación.

2. **QualityMetricsRepository**
   - `findByProducerIdAndMetricDate(Long producerId, LocalDate date)`: Métricas específicas.
   - `findByProducerIdAndDateRange(Long producerId, LocalDate start, LocalDate end)`: Rango de métricas.
   - `findLatestByProducerId(Long producerId)`: Métricas más recientes.
   - `calculateAverageByPeriod(Long producerId, Period period)`: Promedios por período.

#### **External Services Integration**
1. **ClassificationDataService**
   - **Propósito**: Obtiene datos de clasificación para reportes.
   - **Métodos**:
     - `getClassificationResults(Long lotId)`: Resultados de clasificación.
     - `getAggregatedQualityData(Long producerId, DateRange range)`: Datos agregados.

2. **CoffeeLotDataService**
   - **Propósito**: Obtiene información de lotes para análisis.
   - **Métodos**:
     - `getLotProductionData(Long producerId)`: Datos de producción.
     - `getHarvestStatistics(Long producerId, Integer year)`: Estadísticas de cosecha.

3. **NotificationService**
   - **Propósito**: Envío de reportes y alertas via email/SMS.
   - **Métodos**:
     - `sendReportNotification(Report report, List<String> recipients)`: Envía notificación.
     - `sendQualityAlert(QualityAlert alert)`: Envía alerta de calidad.

#### **Event Handling**
1. **ReportingEventHandler**
   - **Propósito**: Maneja eventos para actualización automática de métricas.
   - **Métodos**:
     - `handle(ClassificationCompletedEvent)`: Actualiza métricas con nueva clasificación.
     - `handle(CoffeeLotRegisteredEvent)`: Actualiza estadísticas de producción.

### 4.2.5.5. Bounded Context Software Architecture Component Level Diagrams

[![structurizr-106404-Reporting-Component-Diagram.png](https://i.postimg.cc/1zJ9YmDH/structurizr-106404-Reporting-Component-Diagram.png)](https://postimg.cc/SXYFnpT2)

### 4.2.5.6.  Bounded Context Software Architecture Code Level Diagrams

En esta sección se presentan los diagramas UML a nivel de código para el contexto determinado.

#### 4.2.5.6.1. Bounded Context Domain Layer Class Diagrams

[![Captura-de-pantalla-2025-09-20-183847.png](https://i.postimg.cc/cHVkZz3z/Captura-de-pantalla-2025-09-20-183847.png)](https://postimg.cc/TLJJJCCj)

#### 4.2.5.6.2. Bounded Context Database Design Diagram

[![Captura-de-pantalla-2025-09-20-184546.png](https://i.postimg.cc/2yQstYtG/Captura-de-pantalla-2025-09-20-184546.png)](https://postimg.cc/H8LvJqd8)


---

## 4.2.6. Bounded Context: User Support

El **User Support Bounded Context** gestiona el soporte técnico y atención al cliente, incluyendo canales como WhatsApp, soporte telefónico y documentación de ayuda. Además gestiona tickets de solicitudes para grabar la fecha en la base de datos.

### 4.2.6.1. Domain Layer

La Domain Layer del User Support Bounded Context encapsula la lógica de negocio relacionada con la gestión de tickets de soporte y el intercambio de mensajes entre usuarios y el equipo de soporte técnico. Además, genera los tickets de la solicitud a la consulta para que la hora quede registrada.

#### **Aggregates**
1. **SupportTicket**
   - **Propósito**: Agregado raíz que representa un caso de soporte desde su creación hasta su resolución.
   - **Atributos**:
     - `ticketId`: Identificador único del ticket.
     - `userId`: Usuario que reporta el problema.
     - `category`: Categoría del problema (TECHNICAL, BILLING, TRAINING, FEATURE_REQUEST).
     - `title`: Título descriptivo del problema.
     - `description`: Descripción detallada del problema.
     - `status`: Estado actual (OPEN, IN_PROGRESS, RESOLVED, CLOSED).
     - `priority`: Prioridad del ticket (LOW, MEDIUM, HIGH, CRITICAL).
     - `messages`: Lista de mensajes intercambiados.
     - `createdAt`: Fecha y hora de creación.
     - `resolvedAt`: Fecha y hora de resolución.
   - **Métodos**:
     - `createTicket()`: Crea ticket con validaciones básicas.
     - `addMessage(TicketMessage message)`: Agrega nuevo mensaje al ticket.
     - `updateStatus(TicketStatus status)`: Actualiza estado del ticket.
     - `resolveTicket()`: Marca ticket como resuelto.
     - `reopenTicket()`: Reabre ticket cerrado.
     - `changePriority(Priority priority)`: Cambia prioridad del ticket.
   - **Características**:
     - Extiende `AuditableAbstractAggregateRoot` para trazabilidad.
     - Implementa máquina de estados simple para transiciones válidas.

#### **Entities**
1. **TicketMessage**
   - **Propósito**: Entidad que representa cada mensaje intercambiado en el ticket.
   - **Atributos**:
     - `messageId`: Identificador único del mensaje.
     - `ticketId`: Ticket al que pertenece el mensaje.
     - `userId`: Usuario que envió el mensaje.
     - `message`: Contenido del mensaje.
     - `isFromSupport`: Indica si el mensaje proviene del equipo de soporte.
     - `sentAt`: Fecha y hora del envío.
   - **Métodos**:
     - `createMessage()`: Crea nuevo mensaje con validaciones.
     - `markAsRead()`: Marca mensaje como leído.

#### **Value Objects**
1. **TicketId**
   - Representa identificador único de ticket de soporte.
   - **Atributos**: `value` (String con formato temporal).
   - **Patrón**: `TKT-YYYYMMDD-NNNN`.

2. **TicketCategory**
   - Enumeración de categorías de ticket:
     - `TECHNICAL`, `BILLING`, `TRAINING`, `FEATURE_REQUEST`, `GENERAL`.

3. **Priority**
   - Enumeración de prioridades de ticket:
     - `LOW`, `MEDIUM`, `HIGH`, `CRITICAL`.

4. **TicketStatus**
   - Estados posibles del ticket: `OPEN`, `IN_PROGRESS`, `RESOLVED`, `CLOSED`.

5. **MessageContent**
   - Contenido del mensaje con validaciones.
   - **Atributos**: `text`, `timestamp`.
   - **Validaciones**: No vacío, longitud máxima.

#### **Commands**
1. **CreateSupportTicketCommand**
   - Crea nuevo ticket de soporte.
   - **Atributos**: `userId`, `category`, `title`, `description`, `priority`.
   - **Validaciones**: Usuario válido, título y descripción no vacíos.

2. **AddTicketMessageCommand**
   - Agrega mensaje a un ticket existente.
   - **Atributos**: `ticketId`, `userId`, `message`, `isFromSupport`.
   - **Validaciones**: Ticket existe, mensaje no vacío.

3. **UpdateTicketStatusCommand**
   - Actualiza estado del ticket.
   - **Atributos**: `ticketId`, `newStatus`, `userId`.
   - **Validaciones**: Transición de estado válida.

4. **ResolveTicketCommand**
   - Marca ticket como resuelto.
   - **Atributos**: `ticketId`, `resolutionMessage`, `userId`.

5. **ChangeTicketPriorityCommand**
   - Cambia prioridad del ticket.
   - **Atributos**: `ticketId`, `newPriority`, `userId`.

#### **Queries**
1. **GetSupportTicketQuery**
   - Recupera ticket específico con todos los mensajes.
   - **Atributos**: `ticketId`, `includeMessages`.

2. **GetUserTicketsQuery**
   - Obtiene todos los tickets de un usuario.
   - **Atributos**: `userId`, `status`, `category`.

3. **GetTicketMessagesQuery**
   - Obtiene mensajes de un ticket específico.
   - **Atributos**: `ticketId`, `orderBy`.

4. **GetOpenTicketsQuery**
   - Lista tickets abiertos para el equipo de soporte.
   - **Atributos**: `priority`, `category`, `dateRange`.

#### **Events**
1. **SupportTicketCreatedEvent**
   - Se dispara al crear nuevo ticket.
   - **Atributos**: `ticketId`, `userId`, `category`, `priority`.

2. **TicketMessageAddedEvent**
   - Se dispara al agregar nuevo mensaje.
   - **Atributos**: `ticketId`, `messageId`, `isFromSupport`.

3. **TicketStatusChangedEvent**
   - Se dispara al cambiar estado del ticket.
   - **Atributos**: `ticketId`, `previousStatus`, `newStatus`.

4. **TicketResolvedEvent**
   - Se dispara al resolver ticket.
   - **Atributos**: `ticketId`, `resolutionTime`, `userId`.

### 4.2.6.2. Interface Layer

#### **Controllers**
1. **SupportTicketController**
   - **Endpoints**:
     - `POST /api/v1/support/tickets` - Crear nuevo ticket
     - `GET /api/v1/support/tickets/{ticketId}` - Obtener ticket específico
     - `GET /api/v1/support/tickets/user/{userId}` - Tickets por usuario
     - `PUT /api/v1/support/tickets/{ticketId}/status` - Actualizar estado
     - `PUT /api/v1/support/tickets/{ticketId}/priority` - Cambiar prioridad
     - `POST /api/v1/support/tickets/{ticketId}/messages` - Agregar mensaje

2. **SupportDashboardController**
   - **Endpoints**:
     - `GET /api/v1/support/dashboard/open-tickets` - Tickets abiertos
     - `GET /api/v1/support/dashboard/stats` - Estadísticas de soporte
     - `GET /api/v1/support/dashboard/priority-tickets` - Tickets por prioridad

#### **Resources**
1. **CreateTicketResource**
   - **Atributos**: `category`, `title`, `description`, `priority`.

2. **SupportTicketResource**
   - **Atributos**: `ticketId`, `userId`, `category`, `title`, `status`, `priority`, `createdAt`, `resolvedAt`.

3. **TicketMessageResource**
   - **Atributos**: `messageId`, `ticketId`, `userId`, `message`, `isFromSupport`, `sentAt`.

4. **UpdateTicketStatusResource**
   - **Atributos**: `newStatus`.

5. **AddMessageResource**
   - **Atributos**: `message`, `isFromSupport`.

#### **Transformers**
1. **CreateTicketCommandFromResourceAssembler**
   - Convierte `CreateTicketResource` a `CreateSupportTicketCommand`.

2. **SupportTicketResourceFromEntityAssembler**
   - Convierte entidad `SupportTicket` a `SupportTicketResource`.

3. **TicketMessageResourceFromEntityAssembler**
   - Convierte entidad `TicketMessage` a `TicketMessageResource`.

### 4.2.6.3. Application Layer

#### **Command Services**
1. **SupportTicketCommandServiceImpl**
   - **Métodos**:
     - `handle(CreateSupportTicketCommand)`: Crea ticket con validaciones básicas.
     - `handle(AddTicketMessageCommand)`: Agrega mensaje al ticket.
     - `handle(UpdateTicketStatusCommand)`: Actualiza estado con validaciones.
     - `handle(ResolveTicketCommand)`: Resuelve ticket y registra timestamp.
   - **Validaciones**:
     - Verificación de existencia del usuario.
     - Validación de estados permitidos para transiciones.
     - Control de permisos para actualizar tickets.

#### **Query Services**
1. **SupportTicketQueryServiceImpl**
   - **Métodos**:
     - `handle(GetSupportTicketQuery)`: Recupera ticket con mensajes.
     - `handle(GetUserTicketsQuery)`: Lista tickets del usuario con filtros.
     - `handle(GetTicketMessagesQuery)`: Obtiene conversación completa.
     - `handle(GetOpenTicketsQuery)`: Lista tickets para equipo de soporte.

#### **Domain Services**
1. **TicketNotificationService**
   - **Propósito**: Servicio para envío de notificaciones relacionadas con tickets.
   - **Métodos**:
     - `notifyTicketCreated(SupportTicket ticket)`: Notifica creación a soporte.
     - `notifyNewMessage(TicketMessage message)`: Notifica nuevo mensaje.
     - `notifyTicketResolved(SupportTicket ticket)`: Notifica resolución al usuario.

2. **TicketValidationService**
   - **Propósito**: Validaciones complejas de reglas de negocio para tickets.
   - **Métodos**:
     - `validateStatusTransition(TicketStatus from, TicketStatus to)`: Valida transiciones.
     - `canUserUpdateTicket(Long userId, SupportTicket ticket)`: Verifica permisos.
     - `validateTicketContent(String title, String description)`: Valida contenido.

### 4.2.6.4. Infrastructure Layer

#### **Persistencia (JPA Repositories)**
1. **SupportTicketRepository**
   - `findById(Long id)`: Busca ticket por ID.
   - `findByUserId(Long userId)`: Tickets de un usuario.
   - `findByStatus(String status)`: Tickets por estado.
   - `findByCategory(String category)`: Tickets por categoría.
   - `findByPriority(String priority)`: Tickets por prioridad.
   - `findOpenTicketsOrderByPriority()`: Tickets abiertos ordenados por prioridad.

2. **TicketMessageRepository**
   - `findByTicketId(Long ticketId)`: Mensajes de un ticket.
   - `findByTicketIdOrderBySentAt(Long ticketId)`: Mensajes ordenados cronológicamente.
   - `countUnreadMessagesByTicket(Long ticketId)`: Cuenta mensajes no leídos.

#### **External Services Integration**
1. **EmailNotificationService**
   - **Propósito**: Notificaciones por email para tickets.
   - **Métodos**:
     - `sendTicketCreatedEmail(SupportTicket ticket)`: Email de confirmación.
     - `sendNewMessageEmail(TicketMessage message)`: Notifica nuevo mensaje.
     - `sendTicketResolvedEmail(SupportTicket ticket)`: Notifica resolución.

2. **UserService**
   - **Propósito**: Integración con el bounded context de usuarios.
   - **Métodos**:
     - `getUserById(Long userId)`: Obtiene información del usuario.
     - `getUserContactInfo(Long userId)`: Obtiene datos de contacto.

#### **Event Handling**
1. **SupportEventHandler**
   - **Propósito**: Maneja eventos relacionados con soporte.
   - **Métodos**:
     - `handle(SupportTicketCreatedEvent)`: Procesa creación y envía notificaciones.
     - `handle(TicketMessageAddedEvent)`: Procesa nuevo mensaje.
     - `handle(TicketResolvedEvent)`: Procesa resolución y actualiza métricas.

### 4.2.6.5. Bounded Context Software Architecture Component Level Diagrams

[![structurizr-106404-User-Support-Component-Diagram.png](https://i.postimg.cc/YCBqvyp1/structurizr-106404-User-Support-Component-Diagram.png)](https://postimg.cc/CzJVt7n1)

### 4.2.6.6.  Bounded Context Software Architecture Code Level Diagrams

En esta sección se presentan los diagramas UML a nivel de código para el contexto determinado.

#### 4.2.6.6.1. Bounded Context Domain Layer Class Diagrams

[![Captura-de-pantalla-2025-09-20-183028.png](https://i.postimg.cc/RhS91qs9/Captura-de-pantalla-2025-09-20-183028.png)](https://postimg.cc/ygbws6Cr)

#### 4.2.6.6.2. Bounded Context Database Design Diagram

[![Captura-de-pantalla-2025-09-20-182449.png](https://i.postimg.cc/BbTLb880/Captura-de-pantalla-2025-09-20-182449.png)](https://postimg.cc/bSvNFwHC)


---


# Conclusiones

**TB1**<br>

Identificar contextos candidatos es un paso clave para gestionar la complejidad en el desarrollo de sistemas. Se trata de un análisis minucioso que busca entender los elementos centrales del sistema y sus interconexiones. A partir de ahí, se procede a agrupar estos elementos en 'contextos delimitados' lógicos y coherentes. Esta separación no solo facilita el diseño y la implementación, sino que también tiene como meta principal potenciar la escalabilidad, el desempeño y la mantenibilidad del sistema resultante.

Identificar sistemas externos es importante para definir con claridad los límites del sistema y comprender las dependencias con su entorno. Este análisis permite reconocer qué funcionalidades provienen de terceros, qué servicios deben integrarse y qué restricciones externas condicionan el diseño. Además, visibiliza riesgos asociados, como la disponibilidad o confiabilidad de dichos sistemas, y orienta la planificación de mecanismos de integración, seguridad y monitoreo. En consecuencia, este paso no solo aporta a la correcta delimitación de responsabilidades, sino que también fortalece la robustez y resiliencia de la arquitectura.


---

# Bibliografía

<!-- Contenido de la bibliografía -->

---

# Anexos

## Figuras

### TB1

#### Database Diagram
[![1-11zon.png](https://i.postimg.cc/8z7mtH9X/1-11zon.png)](https://postimg.cc/G41Dpkcv)

#### Class Diagram

[![beans-diagram-class.png](https://i.postimg.cc/h4M8n6q3/beans-diagram-class.png)](https://postimg.cc/Z0BvFfnr)

